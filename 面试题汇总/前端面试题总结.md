# 前端面试题总结

## 一、计算机网络相关的

### 1.1 从输入URL到页面呈现都发生了什么

#### 第一步：URL解析

一、地址解析。例如下面

>```js
>http://user:pass@www.baidu.com:80/index.html?lx=1&from=wx#video
>```
>
>1. `http`：协议。除了http外还有 `https`、`ftp`。
>
>2. `user:pass`：登录信息（认证）。
>
>3. `www.baidu.com`：域名，即服务器地址。
>
>4. `80`：端口号。范围：0~65535。
>
>   ==**注意：当我们不添加端口号的时候，浏览器会自动根据协议默认添加端口号。**==
>
>   - HTTP协议默认添加 `80端口号`。
>   - HTTPS协议默认添加 `443端口号`。
>   - FTP协议默认添加 `21端口号`。
>
>5. `index.html`：请求资源的文件路径。
>
>6. `lx=1&from=wx`：查询字符串。格式为（？参数）。
>
>7. `video`：#号后面的字符为哈希值。

二、编码

前后端交互常用的两种编码有：

- 一、`encodeURI/decodeURI` 编码。**这个是对整个URL的编码，主要处理的是空格/中文。**
- 二、`encodeURIComponent/decodeURIComponent` 编码。**这个编码主要对传递的参数进行编码。**

示例：

```js
### encodeURI/decodeURI 编码
let url =
    'http://www.baidu.com:8080/index.html?name=百度一下&from=  http://www.bilibili.com/#yyy'
console.log(encodeURI(url))
//结果:
//http://www.baidu.com:8080/index.htmlname=%E7%99%BE%E5%BA%A6%E4%B8%80%E4%B8%8B&from=%20%20http://www.bilibili.com/#yyy


### encodeURIComponent/decodeURIComponent 编码
let url2 = `http://www.baidu.com:8080/index.html?name=${encodeURIComponent(
  '百度一下'
)}&from=${encodeURIComponent('http://www.bilibili.com/')}#yyy`
console.log(url2)
//结果：
//http://www.baidu.com:8080/index.html?name=%E7%99%BE%E5%BA%A6%E4%B8%80%E4%B8%8B&from=http%3A%2F%2Fwww.bilibili.com%2F#yyy
```



#### 第二步：缓存检查

**一、缓存检查的顺序：**

- 一、首先会检查是否有强缓存，如果有且未失效，那么走强缓存。
- 二、如果没有或者该缓存已失效了，那么会继续检查是否有协商缓存。
- 三、如果有协商缓存，那么走协商缓存。如果没有则获取最新的数据。



**二、缓存位置：**

>缓存位置有两个：
>
>- Memory Cache 内存缓存。
>- DIsk Cache 硬盘缓存。

- 打开网页：首先会在硬盘缓存中查找是否有匹配，如果有则使用，没有则发送网络请求。
- 普通刷新页面（F5）：因为新的页面没有关闭，因此内存缓存是可用的。所以会优先使用内存缓存，然后才是硬盘缓存。
- 强制刷新页面（Ctril+F5）:浏览器不使用缓存，因此浏览器发送的请求，头部均带有 `Cache-control:no-cache`，服务器直接返回200和最新的内容。 



**三、强缓存（Expires / Cache-Control）：**

==强缓存是后端服务器设置的。==

浏览器对于强缓存的处理：根据第一次发送网络请求资源时返回的响应头来确定的。

- `Expires`：缓存过期时间，用来指定资源到期的时间（HTTP/1.0）
- `Cache-Control`：cache-control: max-age=2592000。当有这个属性和属性值时说明**第一次拿到资源后的2592000秒内（30天）再次发送网络请求，则直接读取缓存中的资源信息。**
- 两者同时存在的时候，`Cache-Control` 优先级高于 `Expires`。

![image-20211107232302485](https://cdn.jsdelivr.net/gh/threey333/Picture/img/20211107232311.png)

强缓存的问题：如果服务器文件更新了，但是本地还是有强缓存，这样导致的结果就是获取不到最新的数据信息。

解决办法有：

1. webpack打包给资源文件添加hash名。这样做是当服务器更新资源后，让资源文件名称和之前不一样，这样页面就会自动导入全新的资源信息。

   ```js
   index.dadas2132.js
   index.adqev5231.js
   ```

2. 没有webpack打包的阶段，可以在文件的后缀设置一个时间戳。这样当文件资源更新后，页面也会自动导入全新的资源信息。

   **做法是：在文件的后缀加？和时间戳。**

   ```html
   <script src="index.js?12312312"></script>
   <script src="query.js?54341832"></script>
   ```

3. 不使用强缓存，选择使用协商缓存。



==**注意：html页面一般不做强缓存。因为要保证每一次html的请求都是正常的HTTP请求。**==



**四、协商缓存 （Last-Modified / ETag）**

==协商缓存也是后端服务器设置的。==

协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识决定是否使用缓存的过程。

![image-20211108010653850](https://cdn.jsdelivr.net/gh/threey333/Picture/img/20211108010654.png)



**五、强缓存和协商缓存的区别：**

- 协商缓存总是会和服务器协商，以至于它一定要发HTTP请求。
- 强缓存则不一定发送HTTP请求。



**六、强缓存和协商缓存的总结：**

1. 强缓存和协商缓存都是后端服务器中设置的。
2. 强缓存和协商缓存是针对静态资源文件而且是不需要经常更新的文件。



**七、数据缓存**

![image-20211108015556866](https://cdn.jsdelivr.net/gh/threey333/Picture/img/20211108015600.png)



**八、缓存检测总结：**

第一次向服务器发送请求：

>1. 强缓存和协商缓存都没有，此时向服务器发送没有任何缓存标识的网络请求。
>
>2. 服务器收到请求后准备内容。比如 
>
>   `Last-Modified`：资源文件最后的更细时间。
>
>   `ETag`：记录的是一个标识（也是根据资源文件生成的，并且每一次资源更新都会重新生成一个`Etag`）。
>
>3. 服务器将内容返回到客户端。
>
>4. 客户端拿到资源信息后进行渲染，并且把资源信息和缓存标识缓存到本地中。

第二次向服务器发送请求：

>1. 检查是否有强缓存，如果有且未失效，那么走强缓存。如果没有或者该缓存已失效了，那么会走协商缓存。
>
>2. 协商缓存设置的信息：
>
>   `If-Modified-Since` = Last-Modified值。
>
>   `IfNone-Match` = ETag值。
>
>3. 将请求发送给服务器。
>
>4. 服务器根据标识判断文件是否更新，如果是没更新则返回304，通知客户端读取缓存信息。如果是更新过，返回200及最新资源信息。



#### 第三步：DNS解析

DNS解析。这一过程DNS会解析URL对于的IP地址，然后根据IP地址建立TCP连接。

一、DNS解析步骤有：递归查询、迭代查询。

**递归查询：**

![image-20211108015949210](https://cdn.jsdelivr.net/gh/threey333/Picture/计算机网络/image-20211108015949210.png)

**迭代查询：**

![image-20211108020022854](https://cdn.jsdelivr.net/gh/threey333/Picture/计算机网络/image-20211108020022854.png)

二、DNS解析时间：

>每一次DNS解析时间预计在20毫秒和120毫秒。  **即使解析时间很少，但也会浪费性能。**

三、服务器拆分优势：

- 资源的合理利用。
- 抗压能力加强。
- 提高HTTP并发。



#### 第四步：TCP三次握手

TCP三次握手：建立连接通道。

>- `seq序号`：用来标识TCP源端向目的端发送的字节流，发送方发送数据时对此进行标记。
>- `ack确认序号`：只有ACK标志位为1时，确认序号字段才有效，ack=seq+1
>- 标志位：ACK：确认序号有效。  RST：重置连接。   SYN：发起一个新连接。    FIN：释放一个连接。

![image-20211108021343327](https://cdn.jsdelivr.net/gh/threey333/Picture/计算机网络/image-20211108021343327.png)

问题：三次握手为什么不用两次，或者四次？

答：`TCP` 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率。

二次会保证不可靠、四次就导致浪费。

#### 第五步：数据传输

- HTTP报文：请求报文和响应报文。
- 响应状态码：
  1. 200 OK
  2. ....



#### 第六步：TCP四次挥手

客户端和服务器端建立好连接通道后，客户端把数据传递给服务器，同时开始发送释放TCP的操作。

![image-20211108022035039](https://cdn.jsdelivr.net/gh/threey333/Picture/计算机网络/image-20211108022035039.png)

面试题：为什么连接的时候是三次握手，关闭的时候却是四次挥手。

- 服务器端收到客户端的SYN连接请求报文后，可以直接发送 `SYN+ACK报文`。
- 但关闭连接时，当服务器端受到FIN报文时，很可能并不会立即关闭连接，所以只能先回复一个ACK报文，告诉客户端：”你发的FIN报文我收到了“，只有等服务器端所有的报文都发送完了，我才发送FIN报文，因此不能一起发送，故需要四次挥手。



#### 第七步：页面渲染









## 二、算法

算法：无序数组，遍历一次，取出第二大的值(说思路)