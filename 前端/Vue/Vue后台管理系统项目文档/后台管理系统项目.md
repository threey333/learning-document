# 后台管理系统项目

## 一、项目准备

### 1.1 技术栈

`Node.js`、`Express`、`MySQL`、`Vue2`

### 1.2 开发工具

`vscode`、`phpstudy`、`navicat`可视化连接数据库工具。

### 1.3 开启本地服务器

大致流程：**前端页面--->接口服务器--->数据库服务器--->数据库**

![image-20210613160757148](D:\Typora记录文档\typora-user-images\image-20210613160757148.png)

#### #第一步：打开数据库服务器

打开`phpstudy`，点击启动服务器。如果没有phpstudy可以官网下载。

![image-20210613161244028](D:\Typora记录文档\typora-user-images\image-20210613161244028.png)

#### #第二步：打开数据库导入数据

1. 先打开`navicat`可视化连接数据库工具。

2. 点击`连接`：创建一个`MySQL`连接。

   ![image-20210613161625026](D:\Typora记录文档\typora-user-images\image-20210613161625026.png)

3. 填写连接名、用户名和密码(root-root，这两个不能乱写因为要和`config`文件的配置一样)。

   ![image-20210613161926820](D:\Typora记录文档\typora-user-images\image-20210613161926820.png)

4. 创建一个数据库 : `shop_admin` 不要乱写, 选择倒数找到 `utf-8`。

5.    双击打开数据库,然后导入`sql文件数据`：文件是`shop_admin.sql `。

   ![image-20210613162105663](D:\Typora记录文档\typora-user-images\image-20210613162105663.png)

如果以上步骤都做了则成功向数据库导入数据。

#### #第三步：开启接口服务器

1. 进入`shop-api`文件目录，然后在终端运行`npm start`或者`npm run start`。
2. 显示成功：`API 接口服务启动成功，占用端口 8888`。

#### #第四步：测试接口

前提是数据连接成功，接口服务器已开启：

>测试接口地址：http://localhost:8888/api/private/v1/login?username=admin&password=123456

#### #第五步：使用项目

- 每次都要先开启`phpstudy`中的`mysql`。
- 每次都要打开`shop-api`，运行`npm start`。



### 1.4 接口项目文件说明

在这次项目中，`shop-api`就是我们项目的接口文件。做这个项目还是有必要对这个文件目录中各文件的说明：

>`config`配置文件目录
>
>- `default.json` 默认配置文件（其中包含数据库配置，jwt配置）
>
>  ![image-20210613164428452](D:\Typora记录文档\typora-user-images\image-20210613164428452.png)
>
>`dao`文件——数据访问层，存放对数据库的增删改查操作
>
>- `DAO.js`文件：提供的公共访问数据库的方法。
>
>`models`——存放具体数据库 ORM 模型文件
>
>`modules`——当前项目模块
>
>- `authorization.js`：API权限验证模块
>- `database.js`：数据库模块（数据库加载基于 nodejs-orm2 库加载）
>- `passport.js`：基于 passport 模块的登录搭建
>- `resextra.js`：API 统一返回结果接口
>
>`node_modules`——项目依赖的第三方模块
>
>`routes`——统一路由
>
>- `api` 提供 api 接口
>- `mapp` 提供移动APP界面
>- `mweb` 提供移动web站点
>
>`services`——**服务层，业务逻辑代码在这一层编写，通过不同的接口获取的数据转换成统一的前端所需要的数据**
>
>![image-20210613165818925](D:\Typora记录文档\typora-user-images\image-20210613165818925.png)
>
>`app.js`——主项目入口文件
>
>`package.json`——项目配置文件



## 二、项目初始化

### 2.1 初始化项目

项目初始化有两种方式：

- 第一种是通过Vue可视化面板初始化项目，步骤：1.在终端命令行输入`vue ui`进入可视化窗口，然后按照项目初始化步骤进行。
- 第二种就是在命令窗口初始化，步骤：`vue create 项目名称`，然后也是按照项目初始化步骤进行就行。

### 2.2 相关插件和依赖的安装

#### # 插件的安装

在这个项目中需要用到`element-ui`组件库，所以要安装它插件。

这里也是有两种方法：这里我推荐在可视化窗口处添加插件，因为方便。

- 一、在==可视化窗口==的插件处添加插件，如下所示：

![image-20210716021052266](D:\Typora记录文档\typora-user-images\image-20210716021052266.png)

![image-20210716021520464](D:\Typora记录文档\typora-user-images\image-20210716021520464.png)

安装完后需要配置一下：

![image-20210716021840184](D:\Typora记录文档\typora-user-images\image-20210716021840184.png)

- 二、在终端命令行处输入`npm install vue-cli-plugin-element`。

然后也是需要向上面一样需要配置成==按需导入==，然后完成安装即可。

#### # 依赖的安装

在后台管理项目中需要到向后端服务器发送请求拿数据，所以这里要安装一个`axios`依赖包。

这里要选择**运行依赖**

![image-20210716022258771](D:\Typora记录文档\typora-user-images\image-20210716022258771.png)

安装 `less-loader加载器`依赖包。

也是在直接在可视化窗口安装依赖包。不过`less-loader`插件需要安装为开发依赖。

![image-20210717031912496](D:\Typora记录文档\typora-user-images\image-20210717031912496.png)

安装完`less加载器`之后还要安装`less`依赖包。命令行窗口：`npm install -D less`

![image-20210717032540264](D:\Typora记录文档\typora-user-images\image-20210717032540264.png)



## 三、将本地项目托管到远程仓库

### 3.1 本地项目托管到远程仓库步骤

远程仓库有`github`、`gitee`。这里我先用gitee，毕竟是国内的。

步骤：

1. 在`gitee`上新建一个仓库，新建仓库后进入到如下这个页面。

   ![image-20210716024543014](D:\Typora记录文档\typora-user-images\image-20210716024543014.png)

2. 按页面中的步骤先==**Git全局设置**==：在命令中输入：

   ![image-20210716024724071](D:\Typora记录文档\typora-user-images\image-20210716024724071.png)

3. 如果已经`git init`创建好一个`git本地仓库`，如果没有创建好则要安装步骤先创建一个git仓库。

   >```shell
   >mkdir vue_shop
   >cd vue_shop
   >git init
   >touch README.md
   >git add README.md
   >git commit -m "first commit"
   >git remote add origin https://gitee.com/threey33/vue_shop.git
   >git push -u origin master
   >```

4. 在命令行窗口进入到项目目录然后输入`git status`查看所有文件状态

   ![image-20210716025600665](D:\Typora记录文档\typora-user-images\image-20210716025600665.png)

   从中可以发现，**有些文件有进行过改动但没有提交到本地仓库中，以至于本地仓库中的文件信息是原来的情况，这样并没有进行到更新，所以下一步就要将这些进行过改动的文件重新提交到本地仓库中。**

5. 输入 `git add . `将所有文件添加到暂存区：

   ![image-20210716030115933](D:\Typora记录文档\typora-user-images\image-20210716030115933.png)

6. 输入 `git commit -m "消息内容(自己命名就行)"` 将暂存区的文件提交到本地仓库中。

   ![image-20210716030525104](D:\Typora记录文档\typora-user-images\image-20210716030525104.png)

   ==**这样就能将有改动过的文件都提交到本地仓库中。**==

7. 再输入 `git status` 查看文件状态：

   ![image-20210716030655012](D:\Typora记录文档\typora-user-images\image-20210716030655012.png)

   可以发现已经没有改动过的文件需要提交了。

8. 剩下的就是将本地仓库的的文件都提交到远程仓库中。

   >指令：
   >
   >```shell
   >git remote add origin https://gitee.com/threey33/vue_shop.git
   >git push -u origin master
   >```

   怎么看结果是否提交成功？回答是在`gitee`刷新一下新建的仓库，出现如下页面则算成功：

   ![image-20210716031223444](D:\Typora记录文档\typora-user-images\image-20210716031223444.png)



## 四、登录页的实现

### 4.1 创建login子分支

在实际开发中，如果要开发新功能了，**==尽量把这些功能都放在新的分支上进行开发==，当这个分支开发完之后，再把这个分支合并到`master主分支`上。**

- 例如这次项目中，要开发登录页，则先创建一个`login子分支`。指令：`git checkout -b login`

  ![image-20210716213334492](D:\Typora记录文档\typora-user-images\image-20210716213334492.png)

  >==注意：==`git checkout -b [branch]`是新建一个分支，并切换到该分支。‘branch'是你要创建的分支名字。

- 然后输入 `git branch` 列出本地的所有的分支。如下图我们正在`login`分支上。

  ![image-20210716213748576](D:\Typora记录文档\typora-user-images\image-20210716213748576.png)



### 4.2 在main.js入口文件配置相关信息

为了方便开发项目，我们在`main.js`入口文件配置下相关信息

#### # 引入axios请求依赖包

由于项目需要用到发送请求，所以在`main.js`引入`axios`

```js
import axios from 'axios'
```

#### # 配置全局的axios请求地址的默认值

```js
axios.defaults.baseURL = 'http://127.0.0.1:8888/api/private/v1/'

//http://127.0.0.1:8888/api/private/v1/'这个地址在接口分档中有。
```

#### # 解决每个组件页面要导入axios依赖包问题

```js
Vue.prototype.$axios = axios
```

#### # 添加请求拦截器

在`login登录页面`，如果登录成功，后台会返回一个`token令牌`来验证权限。

**==为了减少在每个组件页面的网络请求中携带token令牌，直接在发送请求中拦截一下，然后添加token，而token令牌数据存在本地Storage中。==**

```js
// 这个拦截器是axios包里的
axios.interceptors.request.use(function (config) {
  // 在发送请求之前做些什么
  config.headers.Authorization = localStorage.getItem('token')
  // Authorization:授权
  return config
}, function (error) {
  // 对请求错误做些什么
  return Promise.reject(error)
})
```



### 4.3 实现登录login组件

#### # 在element-js文件中导入所需要的组件

在项目初始化时，我们是安装了`vue-cli-plugin-element`插件，这样借助这个插件能实现**导入我们所需要的组件，而不用全部导入。**

![image-20210717210525917](D:\Typora记录文档\typora-user-images\image-20210717210525917.png)

#### # 创建login组件文件

使用单文件组件创建`login组件`。

**html部分：**

```vue
<template>
  <div class="container">
    <!-- 表单元素绑定了loginForm,绑定了表单验证规则rules -->
    <!-- ref作用于html标签,获取的就是当前HTML的信息 -->
    <!-- 采用Layout布局,其中jsutify为水平居中,align为垂直居中 -->
    <el-row
      type='flex'
      justify="center"
      align="middle"
    >
      <el-col :span="8">
        <div class="form_box">
          <img
            src="../assets/logo.png"
            alt="logo"
            draggable="false"
          >
          <el-form
            :model="loginForm"
            :rules="rules"
            ref="loginForm"
          >
            <!-- 用户名 -->
            <el-form-item
              label="用户名"
              prop="username"
            >
              <el-input v-model="loginForm.username"></el-input>
            </el-form-item>
            <!-- 密码 -->
            <!-- prop属性用于校验规则,也就是 -->
            <el-form-item
              label="密码"
              prop="password"
            >
              <el-input
                v-model="loginForm.password"
                @keyup.enter.native="submitForm"
              ></el-input>
            </el-form-item>

            <!-- 登录和重置按钮 -->
            <el-form-item>
              <!--
       type标签属性为类型:
          primary:蓝色
          success:绿色
          danger:红色
      -->
              <el-button
                type="primary"
                @click="submitForm"
                round
              >登录</el-button>
              <el-button
                @click="resetForm"
                round
              >重置</el-button>
            </el-form-item>
          </el-form>
        </div>
      </el-col>
    </el-row>
  </div>
</template>
```

**js逻辑代码部分：**

```js
export default {
  data () {
    return {
      loginForm: {
        username: '',
        password: ''
      },
      rules: {
        username: [
          // trigger:即触发的意思,其中属性值为blue即事件在输入框失去焦点时触发
          // min为最小长度,max为最大长度
          // required为true则有红色的小星号提示要填信息,为false则没有红色的小星号提示信息.
          { required: true, message: '请输入用户名', trigger: 'blur' },
          { min: 4, max: 13, message: '长度在 4 到 13 个字符', trigger: 'blur' }
        ],
        password: [
          { required: true, message: '请输入密码', trigger: 'blur' },
          { min: 4, max: 18, message: '长度在 4 到 18 个字符', trigger: 'blur' }
        ]
      }
    }
  },
  methods: {
    submitForm () {
      // 参数为一个回调函数
      // 参数返回的是true或者false
      this.$refs.loginForm.validate(async (res) => {
        // 如果输入的用户名和密码不符合校验的规则,则不给提交.
        if (!res) {
          return 0
        } else {
          // 登录成功则axios发送请求
          const { data: res } = await this.$axios.post('login', this.loginForm)
          console.log(res)
          if (res.meta.status === 200) {
            // 如何知道用户是否登录？可以使用本地存储用户的token来判断用户是否登录。
            localStorage.setItem('token', res.data.token)
            localStorage.setItem('username', res.data.username)
            // 1.登录成功后提示
            this.$message({
              message: '登录成功',
              type: 'success',
              duration: 1000
            })
            // 2.登录成功路由跳转到home页面
            this.$router.push('/home')
          } else {
            this.$message({
              message: res.meta.msg,
              type: 'error',
              duration: 1000
            })
          }
        }
      })
    },
    // 重置数据方法
    resetForm () {
      this.$refs.loginForm.resetFields()
    }
  }
}
```



#### # 在路由文件中引入login组件

在路由index.js文件中引入login组件，同时添加`路由重定向功能`

![image-20210717213050768](D:\Typora记录文档\typora-user-images\image-20210717213050768.png)



### 4.4 将本地代码提交到远程仓库中

步骤：

- 先`git status`查看哪些文件是有改动过且没添加到本地仓库中。
- 输入`git add .`将这些文件添加到暂存区中。
- 然后`git commit -m "完成了登录功能"`将文件提交到本地仓库中
- 输入`git branch`查看目前所处在哪个分支。
- 输入`git checkout master`切换到`master`主分支上。
- 然后输入`git merge login`合并`login`分支（==**注意！！前提是要在master主分支上合并。**==）
- 最后输入`git push`将本地仓库的代码推送到远程仓库中。

![image-20210717214651517](D:\Typora记录文档\typora-user-images\image-20210717214651517.png)

**但是有这么个问题：在远程仓库上是看到我们提交了新的代码，但是看不到其它分支，比如login分支，怎么解决？**

![image-20210717215139733](D:\Typora记录文档\typora-user-images\image-20210717215139733.png)

解决步骤：

- 先切回`login分支`上，指令：`git checkout login`。

- 然后`git branch`查看是否切换分支成功。

- 最后输入`git push -u origin login`将`login`分支推送到远程仓库中。

  ![image-20210717215443623](D:\Typora记录文档\typora-user-images\image-20210717215443623.png)

- 结果：

  ![image-20210717215517990](D:\Typora记录文档\typora-user-images\image-20210717215517990.png)



## 五、用户管理部分的实现

### 5.1 创建user子分支

步骤：

- 指令：`git checkout -b user`

  ![image-20210718010639042](D:\Typora记录文档\typora-user-images\image-20210718010639042.png)

- 然后输入 `git branch` 列出本地的所有的分支。如下图我们正在`user`分支上。

  ![image-20210718010754072](D:\Typora记录文档\typora-user-images\image-20210718010754072.png)



### 5.2 实现user组件

#### # 在element-js文件中导入所需要的组件

![image-20210718010954797](D:\Typora记录文档\typora-user-images\image-20210718010954797.png)

#### # 创建user组件文件

使用单文件组件创建`user组件`。

**html部分**

```html
<!--
    表格的数据一般是以数组的形式
    表单的数据一般是以对象的形式
    ---------------------------------
      el-table : 表格组件
      - :data="tableData"  显示数据(数组)
      el-table-column : 表格列
      - label 当前列显示的标题文字
      - prop : 读取表格数据里的字段对应的值
    行数由表格数据(数组) 元素的个数决定
  -->
<div>
  <!-- 面包屑  -->
  <!-- separator-class:图标分隔符  -->
  <el-breadcrumb class="bread" separator-class="el-icon-arrow-right">
    <el-breadcrumb-item :to="{ path: '/home' }">首页</el-breadcrumb-item>
    <el-breadcrumb-item>用户管理</el-breadcrumb-item>
    <el-breadcrumb-item>用户列表</el-breadcrumb-item>
  </el-breadcrumb>

  <el-card>
    <!-- 输入框 -->
    <el-row :gutter="20">
      <el-col :span="8">
        <el-input clearable placeholder="请输入内容" v-model="searchText">
          <el-button
            @click="startQuery"
            slot="append"
            icon="el-icon-search"
          ></el-button>
        </el-input>
      </el-col>
      <el-col :span="8">
        <el-button type="primary" @click=" dialogAddUserVisible=true"
          >添加用户</el-button
        >
      </el-col>
    </el-row>

    <!--表格-->
    <el-table :data="usersData" style="width: 100%">
      <el-table-column type="index" label="#"></el-table-column>
      <el-table-column prop="username" label="姓名" align="center" min-width>
      </el-table-column>
      <el-table-column prop="email" label="邮箱" align="center" min-width>
      </el-table-column>
      <el-table-column prop="mobile" label="电话" align="center" min-width>
      </el-table-column>
      <el-table-column prop="role_name" label="角色" align="center" min-width>
      </el-table-column>
      <el-table-column label="状态" align="center" min-width>
        <template slot-scope="scope">
          <!-- 通过 Scoped slot 可以获取到 row, column, $index 和 store（table 内部的状态管理）的数据。 -->
          <el-switch
            v-model="scope.row.mg_state"
            @change="changeState(scope.row)"
          >
          </el-switch>
        </template>
      </el-table-column>
      <el-table-column label="操作" align="center" min-width>
        <template slot-scope="scope">
          <!-- icon:图标，edit:编辑 -->
          <el-button
            plain
            size="mini"
            type="primary"
            icon="el-icon-edit"
            @click="showEditUserDialog(scope.row)"
          ></el-button>
          <el-button
            plain
            size="mini"
            type="danger"
            icon="el-icon-delete"
            @click="deleteUser(scope.row)"
          ></el-button>
          <el-button
            plain
            size="mini"
            type="success"
            icon="el-icon-check"
            @click="showAssignRoleDialog(scope.row)"
            >分配角色</el-button
          >
        </template>
      </el-table-column>
    </el-table>

    <!-- 分页 -->
    <el-pagination
      background
      layout="prev, pager, next"
      :page-size="3"
      :total="total"
      :current-page="pagenum"
      @current-change="changCurPage"
    >
      <!--
        total：总条目数,类型是number
        layout：组件布局，子组件名用逗号分隔
        background：是否为分页按钮添加背景色，类型为布尔值，true即有颜色，false即没有颜色。
       -->
    </el-pagination>
  </el-card>

  <!-- 添加用户对话框 -->
  <!-- el-dialog:对话框 -->
  <el-dialog title="添加用户" :visible.sync="dialogAddUserVisible">
    <el-form :model="addUserForm" label-width="80px" :rules="rules">
      <el-form-item label="用户名:" prop="username">
        <el-input v-model="addUserForm.username"></el-input>
      </el-form-item>
      <el-form-item label="密码:" prop="password">
        <el-input v-model="addUserForm.password"></el-input>
      </el-form-item>
      <el-form-item label="邮箱:" prop="email">
        <el-input v-model="addUserForm.email"></el-input>
      </el-form-item>
      <el-form-item label="电话:" prop="mobile">
        <el-input v-model="addUserForm.mobile"></el-input>
      </el-form-item>
    </el-form>
    <div slot="footer">
      <el-button @click="dialogAddUserVisible = false">取 消</el-button>
      <el-button type="primary" @click="addUser">确 定</el-button>
    </div>
  </el-dialog>

  <!-- 编辑对话框 -->
  <el-dialog title="用户编辑" :visible.sync="dialogeditUserVisible">
    <el-form :model="editUserForm" label-width="80px" :rules="rules">
      <el-form-item label="用户名:">
        <el-tag type="info">{{ editUserForm.username}}</el-tag>
      </el-form-item>
      <el-form-item label="邮箱:" prop="email">
        <el-input v-model="editUserForm.email"></el-input>
      </el-form-item>
      <el-form-item label="电话:" prop="mobile">
        <el-input v-model="editUserForm.mobile"></el-input>
      </el-form-item>
    </el-form>
    <div slot="footer">
      <el-button @click="dialogeditUserVisible=false">取 消</el-button>
      <el-button type="primary" @click="editUser">确 定</el-button>
    </div>
  </el-dialog>

  <!--分配角色对话框  -->
  <el-dialog title="分配角色" :visible.sync="dialogAssignRoleVisible">
    <el-form :model="assignRoleForm" label-width="80px">
      <el-form-item label="用户名">
        <el-tag>{{assignRoleForm.username}}</el-tag>
      </el-form-item>
      <el-form-item label="角色列表">
        <el-select v-model="assignRoleForm.rid" placeholder="请选择角色">
          <!--
            label : 负责显示
            value 负责收集信息
           -->
          <el-option
            v-for="item in rolesData"
            :key="item.id"
            :label="item.roleName"
            :value="item.id"
          ></el-option>
        </el-select>
      </el-form-item>
    </el-form>
    <div slot="footer" class="dialog-footer">
      <el-button @click="dialogAssignRoleVisible = false">取 消</el-button>
      <el-button type="primary" @click="assignRole">确 定</el-button>
    </div>
  </el-dialog>
</div>

```

**js代码部分**

```js
/* eslint-disable */

export default {
  data () {
    return {
      //用户列表数据
      usersData: [{ username: 'yyy', email: '561516@qq.com', mobile: 13513515 }],
      //total:分页的总条目数
      total: 0,
      // textcontent:文本内容
      searchText: '',
      //请求的某一页数,不能写死
      pagenum: 1,
      // dialogAddUserVisible：添加用户对话框开关
      dialogAddUserVisible: false,
      // dialogeditVisible：编辑用户对话框开关
      dialogeditUserVisible: false,
      //addUseForm:添加用户信息的表单数据
      addUserForm: {
        username: '',
        password: '',
        email: '',
        mobile: ''
      },
      // editUserForm:编辑用户信息的表单数据
      editUserForm: {
        username: '',
        email: '',
        mobile: '',
        id: 0
      },
      // 添加用户信息规则
      rules: {
        //校验username
        username: [
          // required为true则有红色的小星号提示要填信息,为false则没有红色的小星号提示信息.
          { required: true, message: '请输入用户名', trigger: 'blur' },
          { min: 6, max: 13, message: '长度在 6 到 13 个字符', trigger: 'blur' }
        ],
        password: [
          // 判断是否输入
          { required: true, message: '请输入密码', trigger: 'blur' },
          // 判断格式是否正确
          { min: 5, max: 10, message: '长度在5-10之间', trigger: 'blur' }
        ],
        //校验email
        email: [
          {
            pattern: /^[A-Za-z\d]+([-_.][A-Za-z\d]+)*@([A-Za-z\d]+[-.])+[A-Za-z\d]{2,4}$/,
            message: '格式不对',
            trigger: 'blur'
          }
        ],
        //校验mobile
        mobile: [
          {
            pattern: /^(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\d{8}$/,
            message: '格式不对',
            trigger: 'blur'
          }
        ]
      },
      //状态的开关
      value1: true,

      // 是否展示分配角色对话框
      dialogAssignRoleVisible: false,
      // 分配角色数据
      assignRoleForm: {
        username: 'threey',
        // id为用户id
        id: '',
        // rid为角色id
        rid: '',
      },
      // 角色信息数据
      rolesData: []
    }
  },
  //created是生命周期钩子函数，在这个钩子函数中可以：1.发送ajax请求，2.操作DOM，3.获取本地存储的数据
  created () {
    // 调用加载用户数据的方法
    this.loadUsersData();
    // 加载角色信息
    this.loadRolesData()
  },
  methods: {
    //方法一：使用Promise加载用户数据方法
    // loadUsersData (pagenum = 1, query = '') {
    //   //axios的get请求格式是get(url,[config])
    //   // const url = 'http://localhost:8888/api/private/v1/users'
    //   axios.get('http://localhost:8888/api/private/v1/users', {
    //     params: {
    //       //query：查询参数，如果为空则代表的是全部
    //       query,
    //       //pagenum:将响应回来数据分成多份,份数=total/pagesize,每份代表一个页数,里面存放了pagesize大小的数据
    //       pagenum,
    //       //pagesize:每页显示的条数
    //       pagesize: 3
    //     },
    //     //在登录后发送的请求信息必须携带token令牌
    //     headers: {
    //       Authorization: localStorage.getItem('token')
    //     }
    //   }).then(res => {
    //     //状态码status为200时则成功
    //     if (res.data.meta.status === 200) {
    //       this.total = res.data.data.total
    //       //把当前页保存起来
    //       this.pagenum = res.data.data.pagenum
    //       //成功后,将响应回来的数据保存起来。
    //       this.usersData = res.data.data.users
    //     }
    //   })
    // },

    // 方法二：使用async异步函数请求数据
    async loadUsersData (pagenum = 1, query = '') {
      // 参数1是当前显示的页面是几，参数2是查询参数。
      const url = 'users'
      const config = {
        params: {
          // 查询参数，如果为空则代表的是全部
          query,
          pagenum,
          //pagesize:每页显示的条数
          pagesize: 3
        }
      }
      // result即是响应回来Promise实例对象的值。
      let result = await this.$axios.get(url, config)
      if (result.data.meta.status === 200) {
        // 保存响应回来的总条数据
        this.total = result.data.data.total
        // 将响应回来的数据保存起来，即保存到usersData
        this.usersData = result.data.data.users
        // console.log(this.usersData);
        // 保存当前的分页的页数
        this.pagenum = result.data.data.pagenum
      }

    },

    //当前页改变加载数据方法.
    changCurPage (curPage) {
      this.loadUsersData(curPage)
    },

    //查询你所知道的所有用户并显示在表格上
    startQuery () {
      //查询第一符合条件用户并显示
      this.loadUsersData(1, this.searchText.trim());
    },

    //添加新用户的信息
    async addUser () {
      //post向后端发送请求，请求数据添加
      // post格式：(url,data,config)
      let result = await this.$axios.post('users', this.addUserForm)
      if (result.data.meta.status === 201) {
        //请求添加数据成功则隐藏添加用户信息的对话框
        this.dialogAddUserVisible = false
        //2.提示, this.$message是element ui里面的方法
        this.$message({
          message: '登录成功',
          type: 'success',
          duration: 800
        })
        //成功后自动刷新
        this.loadUsersData()
      }


    },

    // 改变用户的状态
    async changeState (state) {
      // 1.获取要修改的用户id和状态
      const { id, mg_state } = state
      // 2.向后台服务器发送修改状态请求
      let res = await this.$axios.put(`users/${id}/state/${mg_state}`)

      // 3.判断状态码，然后处理
      if (res.data.meta.status === 200) {
        // 提示
        this.$message({
          message: '更改状态成功',
          type: 'success',
          duration: 800
        })
        // 刷新一下页面
        this.loadUsersData(this.pagenum)
      }
    },

    // 显示 用户编辑对话框
    showEditUserDialog (row) {
      //1. 显示
      this.dialogeditUserVisible = true

      //2.获取数据
      const { username, email, mobile, id } = row
      // 3.利用对象的解构赋值，把数据赋值给editUserForm
      this.editUserForm = { username, email, mobile, id }
    },

    //编辑用户数据
    async editUser () {
      // 1.先获取数据
      const { username, email, mobile, id } = this.editUserForm
      // 2.发送编辑修改请求
      let res = await this.$axios.put(`users/${id}`, { email, mobile })

      // 判断状态码
      if (res.data.meta.status === 200) {
        //隐藏编辑用户对话框
        this.dialogeditUserVisible = false
        this.$message({
          message: '编辑用户成功',
          type: 'success',
          duration: 800
        })
      }
      // 重新加载数据模拟刷新
      this.loadUsersData(this.pagenum)
    },

    // 删除用户信息
    async deleteUser (row) {
      // 1.获取删除用户的id
      const { id } = row
      // 2.使用try...catch结果，以免报错无法捕获
      try {
        // this.$confirm方法放回的是一个Promise对象
        await this.$confirm('此操作将永久删除用户, 是否继续?', '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        })
        let res = await this.$axios.delete(`users/${id}`)

        if (res.data.meta.status === 200) {
          // 提示
          this.$message({
            message: '删除用户成功',
            type: 'success',
            duration: 800
          })

          // 刷新一下
          this.loadUsersData(this.pagenum)
        }
      } catch (error) {
        this.$message({
          message: '已取消删除',
          type: 'info',
          duration: 800
        })
      }

    },

    // 获取所有角色信息
    async loadRolesData () {
      const res = await this.$axios.get(`roles`)
      this.rolesData = res.data.data
    },

    // 显示分配角色对话框方法
    async showAssignRoleDialog (row) {
      // 1.获取用户id、用户姓名：username，由于row里面没有角色id，只能从其它方式获取
      const { id, username } = row
      this.assignRoleForm.username = username
      this.assignRoleForm.id = id

      // 2.根据用户id查询用户信息从而获取角色rid
      const res = await this.$axios.get(`users/${id}`)

      this.assignRoleForm.rid = res.data.data.rid === -1 ? '' : res.data.data.rid
      // console.log(this.assignRoleForm.rid);

      // 3.展示分配角色对话框
      this.dialogAssignRoleVisible = true
    },

    // 分配角色,该角色附带有权限
    async assignRole () {
      // 先获取id和rid
      const { id, rid } = this.assignRoleForm
      // console.log(id, rid);
      const res = await this.$axios.put(`users/${id}/role`, {
        rid
      })
      // console.log(res);
      if (res.data.meta.status === 200) {
        // 1.关闭分配角色对话框
        this.dialogAssignRoleVisible = false
        // 2.提示成功信息
        this.$message({
          message: '分配角色成功',
          type: 'success',
          duration: 800
        })
        // 3.刷新数据
        this.loadUsersData(this.pagenum)
      }
    },
    clearaddUserForm () {
      this.$refs.addUserFormRef.resetFields()
    }
  }
}

```

#### # 在路由文件中引入users组件

引入`users组件`的同时，还要路由导向中指定`path路径`。

![image-20210718011336987](D:\Typora记录文档\typora-user-images\image-20210718011336987.png)



### 5.3 将本地代码提交到远程仓库中

步骤：

- 使用`git add .`将文件提交到暂存区

- 输入`git status`查看文件的状态。

  ![image-20210718011834180](D:\Typora记录文档\typora-user-images\image-20210718011834180.png)

- 输入`git commit -m "完成了用户管理页"`将文件提交到本地仓库中。

  ![image-20210718012057253](D:\Typora记录文档\typora-user-images\image-20210718012057253.png)

- 输入`git push -u origin user`将`user`分支推送到远程仓库中。

  ![image-20210718013106154](D:\Typora记录文档\typora-user-images\image-20210718013106154.png)

- 输入`git branch`查看当前所处哪个分支

- 然后输入`git checkout matser`切换到主分支上

- 输入`git merge user`合并`user`子分支

  ![image-20210718012519889](D:\Typora记录文档\typora-user-images\image-20210718012519889.png)

- 最后输入`git push`将本地仓库的代码推送到远程仓库中。结果如下：

  ![image-20210718013225672](D:\Typora记录文档\typora-user-images\image-20210718013225672.png)



## 六、权限管理部分的实现

### 6.1 创建rights子分支

步骤：

- 输入`git checkout -b rights`创建子分支。
- 然后输入`git push -u origin rights`将`rights`分支推送到远程仓库中。

### 6.2 实现rights组件

**html部分**

```html
<template>
  <div>
    <!-- 面包屑  -->
    <!-- separator-class:图标分隔符  -->
    <el-breadcrumb
      class="bread"
      separator-class="el-icon-arrow-right"
    >
      <el-breadcrumb-item :to="{ path: '/home' }">首页</el-breadcrumb-item>
      <el-breadcrumb-item>权限管理</el-breadcrumb-item>
      <el-breadcrumb-item>权限列表</el-breadcrumb-item>
    </el-breadcrumb>

    <el-card>
      <!-- 权限数据展示表格 -->
      <el-table
        height="794"
        :data="rightsData"
        style="width: 100%"
      >
        <!-- 如果设置了 type=index，可以通过传递 index 属性来自定义索引 -->
        <!-- 通过给 type=index 的列传入 index 属性，可以自定义索引。该属性传入数字时，将作为索引的起始值。也可以传入一个方法，它提供当前行的行号（从 0 开始）作为参数，返回值将作为索引展示 -->
        <el-table-column
          type="index"
          :index="indexMethods"
          align="center"
          label='#'
        >
        </el-table-column>
        <el-table-column
          prop="authName"
          label="权限名称"
          align="center"
        >
        </el-table-column>
        <el-table-column
          prop="path"
          label="路径"
          align="center"
        >
        </el-table-column>
        <el-table-column
          label="权限等级"
          align="center"
        >

          <template slot-scope="scope">
            <!-- 通过 Scoped slot 可以获取到 row, column, $index 和 store（table 内部的状态管理）的数据。 -->
            <!-- 这里的level是String类型 -->
            <span v-if="scope.row.level==0">
              <el-tag>一级</el-tag>
            </span>
            <span v-else-if='scope.row.level==1'>
              <el-tag type="success">二级</el-tag>
            </span>
            <span v-else>
              <el-tag type="warning">三级</el-tag>
            </span>
          </template>
        </el-table-column>
      </el-table>
    </el-card>
  </div>
</template>
```

**js代码部分**

```js
export default {
  data () {
    return {
      rightsData: [{
        authName: '主管',
        path: 'goods',
        level: '一级'
      }]
    }
  },
  created () {
    this.loadRightsData()
  },
  computed: {
    result (row) {
      return row + 1
    }
  },
  methods: {
    // 加载权限数据
    async loadRightsData () {
      // 1.加载权限数据
      const res = await this.$axios.get(`rights/list`)
      // console.log(res);
      if (res.data.meta.status === 200) {
        this.rightsData = res.data.data
      }
    },
    // 处理索引
    // 方法里面有一个参数，index参数 是行号, 从0开始的
    indexMethods (index) {
      return index
    }
  }
}
```



### 6.3 实现roles组件

**html部分**

```html
<div>
  <!-- 面包屑  -->
  <!-- separator-class:图标分隔符  -->
  <el-breadcrumb class="bread" separator-class="el-icon-arrow-right">
    <el-breadcrumb-item :to="{ path: '/home' }">首页</el-breadcrumb-item>
    <el-breadcrumb-item>权限管理</el-breadcrumb-item>
    <el-breadcrumb-item>角色列表</el-breadcrumb-item>
  </el-breadcrumb>
  <el-card>
    <el-table :data="rolesData" style="width: 100%">
      <!-- 展开行 -->
      <el-table-column type="expand">
        <template v-slot:default="scope">
          <!-- 第一层 -->
          <!-- 第一层展示该角色的权限范围 -->
          <!-- closable:图标中的×号 -->
          <el-row
            class="row1"
            v-for="item1 of scope.row.children"
            :key="item1.id"
          >
            <el-col :span="4">
              <el-tag closable>{{item1.authName}}</el-tag>
              <i class="el-icon-arrow-right"></i>
            </el-col>
            <el-col :span="20">
              <!-- 第二层 -->
              <!-- 第二层展示的是每个权限下的列表类型 -->
              <el-row
                class="row2"
                v-for="item2 of item1.children"
                :key="item2.id"
              >
                <el-col :span="4">
                  <el-tag type="success" closable>{{ item2.authName }}</el-tag>
                  <i class="el-icon-arrow-right"></i>
                </el-col>
                <el-col :span="20">
                  <!-- 第三层 -->
                  <!-- 第三层展示的是每个权限下有的功能 -->
                  <el-tag
                    class="tag3"
                    type="warning"
                    closable
                    v-for="item3 of item2.children"
                    :key="item3.id"
                    >{{item3.authName}}
                  </el-tag>
                </el-col>
              </el-row>
            </el-col>
          </el-row>
        </template>
      </el-table-column>

      <!-- index：标签属性,这时可以给它传入方法或者变量。 -->
      <el-table-column
        type="index"
        :index="indexMethod"
        label="#"
        align="center"
      >
      </el-table-column>
      <el-table-column prop="roleName" label="角色名称" align="center">
      </el-table-column>
      <el-table-column prop="roleDesc" label="描述" align="center">
      </el-table-column>
      <el-table-column label="操作" align="center">
        <template v-slot:default="scope">
          <el-button
            size="mini"
            type="primary"
            icon="el-icon-edit"
            @click="editRoles(scope.row)"
            plain
          ></el-button>
          <el-button
            size="mini"
            type="danger"
            icon="el-icon-delete"
            @click="deleteRoles(scope.row.id)"
            plain
          ></el-button>
          <el-button
            size="mini"
            type="success"
            icon="el-icon-edit"
            plain
            @click="showAssignRightsDialog(scope.row)"
            >分配权限</el-button
          >
        </template>
      </el-table-column>
    </el-table>
  </el-card>

  <!-- 修改角色对话框 -->
  <el-dialog title="修改角色" :visible.sync=" rolesDialogVisible" width="40%">
    <el-form
      ref="rolesForm"
      :model="rolesFormData"
      :rules="roleRules"
      label-width="100px"
    >
      <el-form-item label="角色名称" prop="roleName">
        <el-input v-model="rolesFormData.roleName"></el-input>
      </el-form-item>
      <el-form-item label="角色描述">
        <el-input v-model="rolesFormData.roleDesc"></el-input>
      </el-form-item>
    </el-form>
    <span slot="footer" class="dialog-footer">
      <el-button @click="rolesDialogVisible = false">取 消</el-button>
      <el-button type="primary" @click="sureEditRole">确 定</el-button>
    </span>
  </el-dialog>

  <!-- 分配权限对话框 -->
  <!-- visible是否显示对话框，支持.sync 修饰符 -->
  <el-dialog
    title="角色授权"
    :visible.sync="dialogAssignRightsVisible"
    center
    top="2vh"
  >
    <!-- 树形控件 -->
    <!--
        其中：default-expanded-keys：默认展开的节点的 key 的数组
              default-checked-keys：默认选中的节点
              show-checkbox：节点是否被选中，默认为false
              node-key 属性：每个树节点用来作为唯一标识的属性
      -->
    <el-tree
      ref="tree"
      :data="data"
      show-checkbox
      node-key="id"
      :props="defaultProps"
      :default-expand-all="true"
    >
    </el-tree>
    <div slot="footer" class="dialog-footer">
      <el-button @click="dialogAssignRightsVisible = false">取 消</el-button>
      <el-button type="primary" @click="assignRights">确 定</el-button>
    </div>
  </el-dialog>
</div>

```

**js代码部分**

```js
export default {
  data () {
    return {
      rolesData: [{ roleName: '主管', roleDesc: '技术负责人' }],
      // 是否显示修改角色对话框
      rolesDialogVisible: false,
      // 是否显示分配 权限对话框
      dialogAssignRightsVisible: false,
      // 修改角色数据表单对象
      rolesFormData: {
        roid: '',
        roleName: '',
        roleDesc: ''
      },
      // 角色表单对象规则
      roleRules: {
        roleName: [{ required: true, message: '请输入角色名称', trigger: 'blur' }]
      },
      data: [
        {
          id: 1,
          label: '一级 1',
          children: [{
            id: 4,
            label: '二级 1-1',
            children: [{
              id: 9,
              label: '三级 1-1-1'
            }, {
              id: 10,
              label: '三级 1-1-2'
            }]
          }]
        }, {
          id: 2,
          label: '一级 2',
          children: [{
            id: 5,
            label: '二级 2-1'
          }, {
            id: 6,
            label: '二级 2-2'
          }]
        }, {
          id: 3,
          label: '一级 3',
          children: [{
            id: 7,
            label: '二级 3-1'
          }, {
            id: 8,
            label: '二级 3-2'
          }]
        }],
      defaultProps: {
        // children : 负责显示结构
        // label : 负责显示标题
        children: 'children',
        label: 'authName'
      },
      // 当点击分配权限对话框的时候，记录保留要分配权限角色的id
      roleId: 0
    }
  },
  // 生命周期钩子函数
  created () {
    this.loadRolesData()
    this.loadRightsData()
  },
  methods: {
    // 处理索引
    indexMethod (index) {
      return index
    },
    // 加载角色列表和角色描述的所有数据
    async loadRolesData () {
      const { data: res } = await this.$axios.get('roles')
      console.log(res)
      if (res.meta.status === 200) {
        this.rolesData = res.data
      }
    },
    // 获取所有的权限信息
    async loadRightsData () {
      const { data: res } = await this.$axios.get('rights/tree')
      console.log(res)
      if (res.meta.status === 200) {
        this.data = res.data
      }
    },

    // 加载分配权限的对话框
    showAssignRightsDialog (row) {
      // 1.获取要分配权限那一行的角色id
      // console.log(row)
      this.roleId = row.id

      // 3.展开分配权限的对话框
      this.dialogAssignRightsVisible = true // DOM渲染是异步操作的

      // 4.获取 row 里面每一个权限的第三层权限功能信息的id
      const keys = []
      // forEach是回调函数
      row.children.forEach(item1 => {
        item1.children.forEach(item2 => {
          item2.children.forEach(tag3 => {
            // 获取权限功能信息的id
            keys.push(tag3.id)
          })
        })
      })
      // console.log(keys)
      // this.$nextTick()将回调延迟到下次 DOM 更新循环之后执行
      this.$nextTick(() => {
        // 如果需要通过 key 来获取或设置，则必须设置node-key。
        // setCheckedKeys方法是element-ui的方法,用法示例：this.$refs.tree.setCheckedKeys([3]);
        this.$refs.tree.setCheckedKeys(keys)
        // 通过使用这个方法就可以获取该角色所有权限信息，并且显示在分配权限的对话框中
      })
    },

    // 获取选中后的权限信息并且发送给后台进行更新修改，从而实现分配权限
    async assignRights () {
      // 1.获取全选和半选中的keys
      // 获取全选中节点的key
      const keys1 = this.$refs.tree.getCheckedKeys()
      // 获取半选中节点的key
      const keys2 = this.$refs.tree.getHalfCheckedKeys()
      // console.log(keys1)
      // console.log(keys2)

      // 2.将全选和半选中的keys拼接在一起
      const keys3 = keys1.concat(keys2)
      // console.log(keys3)

      // 3.将选中的发送给后台进行修改更新。
      // console.log(this.roleId)
      const res = await this.$axios.post(`roles/${this.roleId}/rights`, {
        // [1,4,7]  => '1,4,7'
        // rids：权限 ID 列表，即要分配权限列表的ID数组，这里要把数组变为字符串
        rids: keys3.join(',')
      })
      console.log(res)
      // 如果更新成功，关闭分配权限对话框
      if (res.data.meta.status === 200) {
        // 关闭分配权限对话框
        this.dialogAssignRightsVisible = false
        // 提示修改成功信息
        this.$message({
          message: '角色授权成功',
          type: 'success',
          duration: 800
        })
        // 刷新页面
        this.loadRolesData()
      } else {
        this.$message({
          message: '角色授权失败',
          type: 'error',
          duration: 800
        })
      }
    },

    // 编辑提交角色
    editRoles (row) {
      this.rolesFormData.roid = row.id
      this.rolesFormData.roleName = row.roleName
      this.rolesFormData.roleDesc = row.roleDesc
      this.rolesDialogVisible = true
    },
    // 确认提交修改用户的信息
    async sureEditRole () {
      const { roid: id, roleName, roleDesc } = this.rolesFormData
      const { data: res } = await this.$axios.put(`roles/${id}`, {
        roleName, roleDesc
      })
      console.log(res)
      if (res.meta.status !== 200) {
        return this.$message.error('修改角色失败')
      } else {
        this.$message({
          message: '修改角色成功',
          type: 'success',
          duration: 800
        })
        this.rolesDialogVisible = false
        // 刷新数据
        this.loadRolesData()
      }
    },
    // 删除角色
    async deleteRoles (id) {
      console.log(id)
      try {
        // this.$confirm方法放回的是一个Promise对象
        await this.$confirm('此操作将永久删除该商品信息, 是否继续?', '提示', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        })
        const { data: res } = await this.$axios.delete(`roles/${id}`)
        if (res.meta.status === 200) {
          this.$message({
            message: '删除角色成功',
            type: 'success',
            duration: 800
          })
          this.loadRolesData()
        }
      } catch (error) {
        this.$message({
          message: '已取消删除',
          type: 'info',
          duration: 800
        })
      }
    }
  }
}

```

**css样式部分**

```css
.row1 {
  border-bottom: 1px dashed #ccc;
  margin-top: 10px;
}
.row1:last-child {
  border: none;
}
.row2 {
  margin-bottom: 15px;
}
.tag3 {
  margin: 0 5px;
}
```



### 6.4 将权限管理的本地代码提交到远程仓库中

步骤：

- 输入`git add .`将文件提交到暂存区。
- 输入`git commit -m “完成了权限管理功能的开发”`将文件从暂存区提交到本地仓库。
- 输入`git push`将文件从本地仓库提交到远程仓库中。（这里提交的仓库是rights子分支仓库。）
- 输入`git checkout master`切换到主分支上。
- 输入`git merge rights`将`rigths`子分支合并到主分支上。
- 最后再输入`git push`将这些文件从本地仓库提交到远程master分支的仓库中。

![image-20210718021940869](D:\Typora记录文档\typora-user-images\image-20210718021940869.png)

这样`master`和`rigths`分支上的文件都是最新的。



## 七、商品管理部分的实现

### 7.1 创建goods_cate商品分类子分支

步骤：

- 输入`git branch`查看当前所在哪个分支。
- 输入`git checkout -b goods_cate`创建`goods_cate`子分支
- 输入`git push -u origin goods_cate`将`goods_cate`子分支推送到远程仓库中。



### 7.2 创建商品分类组件

#### # 安装树形表格组件依赖

指令：`npm install element-tree-grid --save`.即**运行依赖**。

在`main。js`中导入树形表格组件，并全局注册。

```js
// 导入树形表格组件
import ElTreeGrid from 'element-tree-grid'
// 全局注册属性表格组件
Vue.component(ElTreeGrid.name, ElTreeGrid)
```

#### # 创建商品分类组件文件

![image-20210718034007646](D:\Typora记录文档\typora-user-images\image-20210718034007646.png)

#### # 在路由文件中导入商品分类组件

![image-20210718034059104](D:\Typora记录文档\typora-user-images\image-20210718034059104.png)



### 7.3 将商品分类的本地代码提交到远程goods_cate仓库中

步骤：

- 输入`git status`查看文件状态。

  ![image-20210718034639213](D:\Typora记录文档\typora-user-images\image-20210718034639213.png)

- 输入`git add .`将这些文件提交到暂存区中。然后再输入`git status`查看文件是否成功提交到暂存区，绿色则表示提交成功。

  ![image-20210718034815578](D:\Typora记录文档\typora-user-images\image-20210718034815578.png)

- 输入`git commit -m "完成商品分类功能的开发"`将这些文件从暂存区提交到本地仓库中。

- 输入`git push`将这些文件从本地仓库提交到远程`goods_cate`子分支的远程仓库中。

- 输入`git checkout master`切换到主分支master上

- 输入`git branch`查看是否成功切换到master主分支上。

- 输入`git merge goods_cate`将`goods_cate`子分支合并到master上。

- 最后输入`git push`将这些文件提交到远程仓库`master`上。

![image-20210718035306310](D:\Typora记录文档\typora-user-images\image-20210718035306310.png)



### 7.4 创建goods_params分类参数子分支

步骤：

- 输入`git branch`查看当前所处哪个分支
- 输入`git checkout -b goods_params`创建`goods_params`子分支。
- 最后输入`git push -u origin goods_params`将`goods_params`子分支推送到远程仓库中。



### 7.5 创建分类参数组件

#### # 创建分类参数组件文件

![image-20210719020549195](D:\Typora记录文档\typora-user-images\image-20210719020549195.png)

#### # 在路由文件中导入分类参数组件

![image-20210719020645782](D:\Typora记录文档\typora-user-images\image-20210719020645782.png)



### 7.6 将分类参数的本地代码提交到远程goods_params仓库中。

步骤：

- 输入`git branch`查看当前所处在哪个分支。

- 输入`git status`查看文件的状态。

  ![image-20210719020915302](D:\Typora记录文档\typora-user-images\image-20210719020915302.png)

- 输入`git add .`将这些文件提交到暂存区。然后再输入`git status`查看文件是否成功提交到暂存区，绿色则表示提交成功。

  ![image-20210719021020629](D:\Typora记录文档\typora-user-images\image-20210719021020629.png)

- 输入`git commit -m "完成分类参数功能的开发"`将这些文件从暂存区提交到当前分支的本地仓库中。

- 输入`git push`将这些文件提交到远程`goods_params`仓库中。

- 输入`git checkout master`切换到`master`主分支上.

- 输入`git branch`查看是否成功切换到master主分支上。

- 输入`git merge goods_params`将`goods_params`子分支合并到master上。

- 最后输入`git push`将这些文件提交到远程仓库`master`上。



### 7.7 创建goods_list商品列表子分支

步骤：

- 输入`git branch`查看当前所在哪个分支。
- 输入`git checkout -b goods_list`创建`goods_list`子分支
- 输入`git push -u origin goods_list`将`goods_list`子分支推送到远程仓库中。

### 7.8 创建商品列表组件

#### #创建商品列表组件文件

![image-20210719023239929](D:\Typora记录文档\typora-user-images\image-20210719023239929.png)

#### # 在路由文件中引入商品列表组件

![image-20210719023212731](D:\Typora记录文档\typora-user-images\image-20210719023212731.png)



### 7.9 创建添加商品组件

#### # 安装富文本框组件依赖

指令：`npm install vue-quill-editor --save`安装

安装完之后导入该组件的`CSS`和`JS`文件。

```js
// 按需引入富文本编辑器插件
import 'quill/dist/quill.core.css'
import 'quill/dist/quill.snow.css'
import 'quill/dist/quill.bubble.css'
// 按需导入富文本编辑器
import { quillEditor } from 'vue-quill-editor'
```



#### # 创建添加商品组件文件

![image-20210719030526369](D:\Typora记录文档\typora-user-images\image-20210719030526369.png)

#### # 在路由文件中引入添加商品组件

![image-20210719030616813](D:\Typora记录文档\typora-user-images\image-20210719030616813.png)





### 7.10 将商品列表和添加商品的本地代码提交到远程goods_list仓库中。

步骤：

- 输入`git branch`查看当前所处在哪个分支。
- 输入`git status`查看文件的状态。
- 输入`git add .`将这些文件提交到暂存区。然后再输入`git status`查看文件是否成功提交到暂存区，绿色则表示提交成功。
- 输入`git commit -m "完成商品列表功能的开发"`将这些文件从暂存区提交到当前分支的本地仓库中。
- 输入`git push`将这些文件提交到远程`goods_list`仓库中。
- 输入`git checkout master`切换到`master`主分支上.
- 输入`git branch`查看是否成功切换到master主分支上。
- 输入`git merge goods_list`将`goods_list`子分支合并到master上。
- 最后输入`git push`将这些文件提交到远程仓库`master`上。

![image-20210719031526944](D:\Typora记录文档\typora-user-images\image-20210719031526944.png)



## 八、订单管理部分的实现

### 8.1 创建order订单列表子分支

步骤：

- 输入`git branch`查看当前所在哪个分支。
- 输入`git checkout -b order`创建`order`子分支
- 输入`git push -u origin order`将`order`子分支推送到远程仓库中。

![image-20210719031906097](D:\Typora记录文档\typora-user-images\image-20210719031906097.png)



### 8.2 创建订单列表组件

#### # 创建订单列表组件文件

![image-20210719032653056](D:\Typora记录文档\typora-user-images\image-20210719032653056.png)

#### # 在路由文件中引入订单列表组件

![image-20210719032739113](D:\Typora记录文档\typora-user-images\image-20210719032739113.png)



### 8.3 将订单列表本地代码提交到远程order仓库中。

步骤：

- 输入`git branch`查看当前所处在哪个分支。
- 输入`git status`查看文件的状态。
- 输入`git add .`将这些文件提交到暂存区。然后再输入`git status`查看文件是否成功提交到暂存区，绿色则表示提交成功。
- 输入`git commit -m "完成订单列表功能的开发"`将这些文件从暂存区提交到当前分支的本地仓库中。
- 输入`git push`将这些文件提交到远程`order`仓库中。
- 输入`git checkout master`切换到`master`主分支上.
- 输入`git branch`查看是否成功切换到master主分支上。
- 输入`git merge order`将`order`子分支合并到master上。
- 最后输入`git push`将这些文件提交到远程仓库`master`上。

![image-20210719033229153](D:\Typora记录文档\typora-user-images\image-20210719033229153.png)



## 九、数据统计部分的实现

### 9.1 创建report子分支

步骤：

- 输入`git branch`查看当前所在哪个分支。
- 输入`git checkout -b report`创建`report`子分支
- 输入`git push -u origin report`将`report`子分支推送到远程仓库中。

![image-20210719033806395](D:\Typora记录文档\typora-user-images\image-20210719033806395.png)



### 9.2 创建数据列表组件

#### # 安装echarts依赖包

通过 npm 获取 echarts，`npm install echarts --save`

导入步骤：

```js
import * as echarts from 'echarts'

export default {
  data () {
    return {
      // 需要合并的选项
      options: {
        title: {
          text: '用户来源'
        },
        tooltip: {
          trigger: 'axis',
          axisPointer: {
            type: 'cross',
            label: {
              backgroundColor: '#E9EEF3'
            }
          }
        },
        grid: {
          left: '3%',
          right: '4%',
          bottom: '3%',
          containLabel: true
        },
        xAxis: [
          {
            boundaryGap: false
          }
        ],
        yAxis: [
          {
            type: 'value'
          }
        ]
      }
    }
  },
  // 在Vue的生命周期钩子函数mounted上进行echarts初始化，此时Vue页面上的元素，已经被渲染完毕了
  async mounted () {
    // 初始化echarts实例
    var myChart = echarts.init(document.getElementById('main'))

    // 向后端接口请求时间统计图的数据
    const { data: res } = await this.$axios.get('reports/type/1')
    // 绘制图表的配置项和数据
    if (res.meta.status !== 200) {
      return this.$message.error('加载数据失败')
    }

    // 合并数据
    const result = { ...this.options, ...res.data }

    // 绘制图表
    myChart.setOption(result)
  }

}
```

**HTML部分：**

![image-20210719035100273](D:\Typora记录文档\typora-user-images\image-20210719035100273.png)



#### # 创建数量列表组件文件

![image-20210719035205823](D:\Typora记录文档\typora-user-images\image-20210719035205823.png)

#### # 在路由文件中引入该组件

![image-20210719035239110](D:\Typora记录文档\typora-user-images\image-20210719035239110.png)



### 9.3 将数据统计本地代码提交到远程report仓库中

步骤：

- 输入`git branch`查看当前所处在哪个分支。
- 输入`git status`查看文件的状态。
- 输入`git add .`将这些文件提交到暂存区。然后再输入`git status`查看文件是否成功提交到暂存区，绿色则表示提交成功。
- 输入`git commit -m "完成数据列表功能的开发"`将这些文件从暂存区提交到当前分支的本地仓库中。
- 输入`git push`将这些文件提交到远程`order`仓库中。
- 输入`git checkout master`切换到`master`主分支上.
- 输入`git branch`查看是否成功切换到master主分支上。
- 输入`git merge report`将`report`子分支合并到master上。
- 最后输入`git push`将这些文件提交到远程仓库`master`上。

![image-20210719035616895](D:\Typora记录文档\typora-user-images\image-20210719035616895.png)



## 十、项目优化上线

### 10.1 安装nprogress依赖包

通过安装`nprogress依赖包`可以为项目添加进度条效果。

使用`npm install --save nprogress`安装`nprogress`运行依赖。

>使用步骤：
>
>- 在`main.js`入口文件中导入。
>
>  ```js
>  // 导入NProgress 包对应的js和css
>  import NProgress from 'nprogress'
>  import 'nprogress/nprogress.css'
>  ```
>
>- 导入之后使用：
>
>  ```js
>  // 在request拦截器中，展示进度条NProgress.start()
>  axios.interceptors.request.use(function (config) {
>    // 在发送请求之前做些什么
>    NProgress.start()
>    config.headers.Authorization = localStorage.getItem('token')
>    // Authorization:授权
>    return config
>  }, function (error) {
>    // 对请求错误做些什么
>    return Promise.reject(error)
>  })
>  
>  // 在response 拦截器中，隐藏进度条NProgress.done()
>  axios.interceptors.response.use(config => {
>    NProgress.done()
>    return config
>  })
>  ```

效果图：

![image-20210719175604469](D:\Typora记录文档\typora-user-images\image-20210719175604469.png)



### 10.2 在生产环境中移除所有的console

在执行`npm run build`进行打包时，一定要移除所有的`console.log语句`，不然会出现警告提示。

解决办法：使用`babel-plugin-transform-remove-console`插件帮我们在打包过程中移除所有的`console.log语句。`

安装：`npm install babel-plugin-transform-remove-console --save-dev`。

在`babel.config.js`配置文件中添加插件。

![image-20210720002640566](D:\Typora记录文档\typora-user-images\image-20210720002640566.png)

做完以上操作就能在`build`打包解决移除所有的`console.log语句`。



### 10.3 生成打包报告

`cli2`项目打包后的结果：

![image-20210714011713480](D:\Typora记录文档\typora-user-images\image-20210714011713480.png)

`cli3`项目打包后的结果：

![image-20210719191655159](D:\Typora记录文档\typora-user-images\image-20210719191655159.png)

对打包后的结果说明：

>- vendors：即第三模块，比如`vue`、`vue-router`、`element-ui`等等都被打包到`vendors`里面去了，所以打包后显示很大,同时加载时间也很长。
>
> ![image-20210719191906156](D:\Typora记录文档\typora-user-images\image-20210719191906156.png)
>
>- app：主入口文件
>
> ![image-20210719192052259](D:\Typora记录文档\typora-user-images\image-20210719192052259.png)

从打包后结果来看，这里有几个优化问题：

- 依赖项目比较大的，如何减少依赖项的体积？
- 加载时间长的，如何优化打开速度？
- 资源体积太大的，如何把文件优化得更小？

这些问题后面都会回答！！



### 10.4 创建vue.config.js修改webpack的默认配置

在项目目录中创建`vue.config.js`配置文件。

![image-20210719192914358](D:\Typora记录文档\typora-user-images\image-20210719192914358.png)



### 10.5 configureWebpack和chainWebpack

在 `vue.config.js`导出的配置对象中，新增`configureWebpack`或`chainWebpack`节点，来自定义`webpack`的打包配置。

在这里，`configureWebpack`和`chainWebpack`的作用相同，唯一的区别就是它们修改webpack配置的方式不同：

- chainWebpack通过`链式编程`的形式，来修改默认的webpack配置。
- configure通过`操作对象`的形式，来修改默认的webpack配置。

**两者具体的使用差异，可以参考官网地址：**https://cli.vuejs.org/zh/guide/webpack.html#%E7%AE%80%E5%8D%95%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F



### 10.6 通过chainWebpack自定义打包入口

步骤：

- 由原来的`main.js`入口文件改为`main-dev.js`和`main-prod.js`文件，这两个文件一个是开发环境的入口文件，另一个是生产环境的入口文件。

- 在`vue.config.js`中添加相关配置，配置如下：

  ```js
  module.exports = {
    chainWebpack: config => {
      config.when(process.env.NODE_ENV === 'production', config => {
        config.entry('app').clear().add('.src/main-prod.js')
      })
      config.when(process.env.NODE_ENV === 'development', config => {
        config.entry('app').clear().add('./src/main-dev.js')
      })
    }
  }
  ```



### 10.7 自定制首页内容

步骤：

- 在`vue.config.js`配置文件中添加如下配置信息

  ```js
  //生产环境下的
  config.plugin('html').tap(args => {
    args[0].isProd = true
    return args
  })
  //开发环境下的
  config.plugin('html').tap(args => {
    args[0].isProd = false
    return args
  })
  ```

- 在`index.html`入口页面中进行更改：

  **标题：**

  ![image-20210720000125297](D:\Typora记录文档\typora-user-images\image-20210720000125297.png)

  **CDN外部引入第三方依赖包：**

  ```html
  <% if(htmlWebpackPlugin.options.isProd){ %>
    <!--element-ui的样式文件-->
    <link
          rel="stylesheet"
          href="https://unpkg.com/element-ui@2.14.1/lib/theme-chalk/index.css"
          />
    <!--富文本编辑器的样式文件-->
    <link
          href="https://cdn.quilljs.com/1.3.4/quill.core.css"
          rel="stylesheet"
          />
    <link
          href="https://cdn.quilljs.com/1.3.4/quill.snow.css"
          rel="stylesheet"
          />
    <link
          href="https://cdn.quilljs.com/1.3.4/quill.bubble.css"
          rel="stylesheet"
          />
    <!--进度条的样式文件-->
    <link
          href="https://unpkg.com/nprogress@0.2.0/nprogress.css"
          rel="stylesheet"
          />
  
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@4.1.0/dist/echarts.min.js"></script>
    <script src="https://unpkg.com/nprogress@0.2.0/nprogress.js"></script>
    <!-- 过滤时间 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <!--富文本编辑器的js文件-->
    <script src="https://cdn.quilljs.com/1.3.4/quill.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue-quill-editor@3.0.6/dist/vue-quill-editor.js"></script>
    <!-- element-ui 的样式文件 -->
    <script src="https://unpkg.com/element-ui@2.14.1/lib/index.js"></script>
  
    <% } %>
  ```

  

### 10.8 优化打开速度

#### #问题：js包非常大影响加载速度

打包后`app.xxxxxxxx.js`是主入口文件，也就是项目一打开，通过路由会加载很多很多的组件，这样会影响加载速度。

>**加载过程：服务器一打开 => index.html => app=> 很多组件**

#### #解决方法：利用路由懒加载

第一步：首先安装`@babel/plugin-syntax-dynamic-import`插件包

- 这个插件**能够把某个路由下的所有组件都打包在同个异步块 (chunk) 中。即路由懒加载的时候，能把这些异步组件分组放在相同的异步块(chunk)**

第二步：安装完之后在`babel.config.js`文件中添加插件：

![image-20210720004055953](D:\Typora记录文档\typora-user-images\image-20210720004055953.png)

第三步：使用步骤，只需要==使用一个特殊的注释语法==来提供 `chunk name`。

示例：

```js
const Foo = () => import(/* webpackChunkName: "group-foo" */ './Foo.vue')
const Bar = () => import(/* webpackChunkName: "group-foo" */ './Bar.vue')
const Baz = () => import(/* webpackChunkName: "group-foo" */ './Baz.vue')
```

Webpack 会将任何一个`异步模块(异步组件)`与`相同的块名称（chunkName）`组合到`相同的异步块(chunk)`中。



第四步：再利用**==路由懒加载==**，当路由被访问的时候才加载对应组件。这样能提高加载速度，减少不必要的加载时间。

![image-20210714014926938](D:\Typora记录文档\typora-user-images\image-20210714014926938.png)

结合这两者，定义一个能够被 Webpack 自动代码分割的异步组件。

```js
const login = () => import(/* webpackChunkName: "login_home" */ '../components/login.vue')
const home = () => import(/* webpackChunkName: "login_home" */ '../components/home.vue')

const users = () => import(/* webpackChunkName: "users_rights_roles" */ '../components/users/users.vue')
const rights = () => import(/* webpackChunkName: "users_rights_roles" */ '../components/power/rights.vue')
const roles = () => import(/* webpackChunkName: "users_rights_roles" */ '../components/power/role/roles.vue')

const categories = () => import(/* webpackChunkName: "categories_params" */ '../components/goods/categories/categories.vue')
const params = () => import(/* webpackChunkName: "categoreis_params" */ '../components/goods/params/params.vue')

const goods = () => import(/* webpackChunkName: "goods_goodsAdd" */ '../components/goods/list/goods.vue')
const goodsAdd = () => import(/* webpackChunkName: "goods_goodsAdd" */ '../components/goods/list/goodsAdd/goodsAdd.vue')

const order = () => import(/* webpackChunkName: "order_reports" */ '../components/order/orders.vue')
const reports = () => import(/* webpackChunkName: "order_reports" */ '../components/report/reports.vue')
```

之前代码：

![image-20210714015347839](D:\Typora记录文档\typora-user-images\image-20210714015347839.png)

利用路由懒加载后代码：

![image-20210720010324924](D:\Typora记录文档\typora-user-images\image-20210720010324924.png)



#### #优化后对比

之前：`app`入口文件体积过大，影响加载速度。

![image-20210720010212180](D:\Typora记录文档\typora-user-images\image-20210720010212180.png)

路由懒加载优化后：

`app`主入口文件减小了，减小的原因是原来各组件打包压缩后都放到app主入口文件中，路由懒加载优化后，把各组件打包后都成独立的文件，路由加载到需要的组件才进行加载，从而提高了加载速度。

![image-20210720010113483](D:\Typora记录文档\typora-user-images\image-20210720010113483.png)



### 10.9 优化vendor第三方模块依赖包

#### #问题：打包后vendor块体积过大

默认情况下，通过import语法导入的第三方依赖包，最终会被打包合并到同一个文件中（这个文件就是`vendor.xxxxx.js`），从而导致打包成功后，单文件体积过大的问题。

![image-20210714022502286](D:\Typora记录文档\typora-user-images\image-20210714022502286.png)

#### #解决方法：通过externals加载外部CDN资源

第一步：

- 如果是Vue-cli2脚手架的话，直接在`/build/webpack.base.conf.js`，添加配置 ==externals==
- 如果是vue-cli3脚手架的话，在`Vue.config.js`中添加配置 ==externals==

​		**注意**：通过 CDN 引入外部资源的样式文件后，就不需要在 `main-prod.js` 中导入相关资源CSS 文件了（**避免重复加载CSS资源文件**）。所以，直接注释掉`main-prod.js` 中的导入相关资源的样式即可。

>vue-cli2的`externals`配置：
>
>```js
>externals: {
>// 键：表示 导入包语法 from 后面跟着的名称
>// 值：表示 script 引入JS文件时，在全局环境中的变量名称
>vue: 'Vue',
>axios: 'axios',
>'vue-router': 'VueRouter',
>'element-ui': 'ELEMENT',
>nprogress:'NProgress',
>echarts: 'echarts',
>'vue-quill-editor': 'VueQuillEditor'
>}
>```
>
>vue-cli3的`externals`配置：
>
>```js
>config.set('externals', {
>    vue: 'Vue',
>    axios: 'axios',
>    'element-ui': 'ELEMENT',
>    nprogress: 'NProgress',
>    echarts: 'echarts',
>    moment: 'moment',
>    'vue-quill-editor': 'VueQuillEditor'
>})
>```

第二步：

- 在`index.html`入口页面引入CDN提供的js文件

```html
<!--element-ui的样式文件-->
<link rel="stylesheet" href="https://unpkg.com/element-ui@2.14.1/lib/theme-chalk/index.css">
<!--富文本编辑器的样式文件-->
<link href="https://cdn.quilljs.com/1.3.4/quill.core.css" rel="stylesheet">
<link href="https://cdn.quilljs.com/1.3.4/quill.snow.css" rel="stylesheet">
<link href="https://cdn.quilljs.com/1.3.4/quill.bubble.css" rel="stylesheet">
<!--进度条的样式文件-->
<link href="https://unpkg.com/nprogress@0.2.0/nprogress.css" rel="stylesheet">

<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script src="https://unpkg.com/element-ui@2.14.1/lib/index.js"></script>
<script src="https://cdn.jsdelivr.net/npm/echarts@4.1.0/dist/echarts.min.js"></script>
<script src="https://unpkg.com/nprogress@0.2.0/nprogress.js"></script>
<!--富文本编辑器的js文件-->
<script src="https://cdn.quilljs.com/1.3.4/quill.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/vue-quill-editor@3.0.6/dist/vue-quill-editor.js"></script>
```

**==注意：由于我外部引入CDN提供的router文件，导致报错，所以我就不CDN引入了。后续再解决这个问题。==**

第三步：

在`main-prod,js`文件中注释掉element-ui按需加载的文件。

![image-20210719231803869](D:\Typora记录文档\typora-user-images\image-20210719231803869.png)



#### #优化后

![image-20210719231139143](D:\Typora记录文档\typora-user-images\image-20210719231139143.png)



