# 数据结构

## 一、时间复杂度

时间复杂度是指**执行算法所需要的计算工作量。**

说白点就是==程序要执行的次数，而不是指执行时间==。

![时间复杂度](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/时间复杂度.png)

**时间复杂度求法：**

>- 不要低阶项，只要高阶项，并且忽略高阶项系数所剩下的东西。
>
>  ```js
>  //例如
>  aN²+bN+c===>N²
>  ```

## 二、空间复杂度

空间复杂度是指**执行算法所需要的最大内存空间**。

![空间复杂度](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/空间复杂度.png)



## 三、栈stack

### 3.1 理解栈

栈是一种特殊的线性表。它的特点是：只能在表的一端进行操作。可以操作的端叫端顶，不可以操作的端叫端底。

**栈的特性是：后进先出。**

![栈](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/栈.png)

### 3.2 栈在前端的相关用途

栈在前端的相关用途：

- Vue 模板编译将模板字符串转换成 AST。
- 自动更新最新版本的 NPM 包。
- ==函数执行的上下文栈==。



### 3.3 在JS中模拟栈的操作

由于JS中没有栈的数据结构，此时可以用数组来模拟栈的一些操作。

栈常见的操作有：

`push()`：添加一个新元素到栈顶的位置。

`pop()`：移除栈顶的元素，同时返回被移除的元素。

`peek()`：返回栈顶的元素，不对栈做任何修改。

`isEmpty()`：任何栈里有没有任何元素，返回true，否则返回false。

`size()`：回栈里的元素个数。这个方法和数组的length属性很类似。

`toString()`：将栈结构的内容以字符串形式返回。

```js
function Stack () {
  // 栈中的属性
  this.items = []
  // 栈中的方法
  // 压栈
  Stack.prototype.push = function (element) {
    this.items.push(element)
  }
  // 出栈
  Stack.prototype.pop = function () {
    return this.items.pop()
  }
  Stack.prototype.peek = function () {
    return this.items[this.items.length - 1]
  }
  Stack.prototype.isEmpty = function () {
    return this.items.length === 0
  }
  Stack.prototype.size = function () {
    return this.items.length
  }
  Stack.prototype.toString = function () {
    let str = ''
    const length = this.items.length
    for (let i = 0; i < length; i++) {
      str += this.items[i] + ','
    }
    return str
  }
}
```





## 四、队列queue

### 4.1 理解队列

- 队列也是一种特殊的线性表，它的特点是：只能在表的一端进行删除操作，而在表的另一点进行插入操作。
- 可以进行删除操作的端称为**队首**，而可以进行插入操作的端称为**队尾**。删
- 除一个元素称为**出队**，插入一个元素称为**入队**。和栈一样，队列也是一种操作受限制的线性表。
- ==队列的特性：先进先出 (FIFO，First-In-First-Out)。==

![image-20210806205106054](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210806205106054.png)



### 4.2 在JS中模拟队列的操作

在JS中也是没有队列这个数据结构，那么只能用数组来模拟队列的一些操作。

队列的操作有：

- `enqueue(element)`：向队列尾部添加一个或多个新的项。
- `dequeue()`：移除队列的第一项，并返回被移除的元素。
- `front()`：返回队列中第一个元素.即最先进入队列的那一项。队列不做任何变动。
- `isEmpty()`：如果队列中不包含任何元素，返回true，否则返回false。
- `size()`：返回队列中包含的元素个数，与数组的length属性类似。
- ` toString()`：将队列中的内容，转成字符串的形式。

```js
function Queue () {
  // 队列的属性
  this.items = []
  // 队列的方法
  Queue.prototype.enqueue = function (element) {
    this.items.push(element)
  }
  Queue.prototype.dequeue = function () {
    return this.items.shift()
  }
  Queue.prototype.front = function () {
    return this.items[0]
  }
  Queue.prototype.isEmpty = function () {
    return this.items.length == 0
  }
  Queue.prototype.size = function () {
    return this.items.length
  }
  Queue.prototype.toString = function () {
    let str = ''
    for (let i = 0; i < this.items.length; i++) {
      str += this.items[i] + ','
    }
    return str
  }
}
```



### 4.3 队列的经典题目

队列的经典题目：击鼓传花游戏。

> 这游戏规则是：个人围成一圈开始玩游戏，指定一个数，然后开始数数，数到哪个人上，谁就自动离开，然后继续下去，直到剩下一个人为止才结束，这时让你求出剩下的那个人是谁并且原来在哪个位置。

 **解题思路就是用队列实现：**

```js
function game(ele, num) {
  const queue = new Queue()
  // 1.先把人进行排队
  for (let i = 0; i < ele.length; i++) {
    queue.enqueue(ele[i])
  }
  // 记录游戏剩下的最后一个人原来的下标
  let result
  // 4.循环依次进行，直到只剩下一个人.
  while (queue.size() > 1) {
    // 2.队列前端的人数完一个数就要回到队列后端处排队，每个人依次进行
    for (let i = 1; i < num; i++) {
      queue.enqueue(queue.dequeue())
    }
    // 3.此时，站在队列前端的就是数字数完的。这时就要离开游戏。
    queue.dequeue()
  }
  result =
    '游戏最后剩下的人是:' +
    queue.front() +
    ',' +
    '他原来的位置是:' +
    ele.indexOf(queue.front())
  return result
}
const arr = ['threey', 'Ethon', 'Rose', 'Lisa']
console.log(game(arr, 5))
```



### 4.4 优先级队列(priorityQueue)

普通队列插入一个元素，数据会被放在队尾，并且需要处理前面所有的元素才会轮到处理这个数据。

但是`优先级队列`不同，当我们插入一个数据的时候会考虑数据的**优先级**。数据优先级大的排前面，优先级小的排后面。

**在优先级队列中，每个数据不再是一个简简单单的数据，而是包含着数据优先级的。**

#### 4.4.1 在JS实现优先级队列

在JS中是没有优先级队列数据结构的，那么想模拟优先级队列的一些操作，可以使用数组来模拟：

```js
function PriorityQueue() {
/*
        在优先级队列类中再封装一个队列元素类，可以理解为内部类
          @ele：<string>
          @priority：<number>
*/
  function QueueElement(ele, priority) {
    // 保存进入队列的数据和优先级权限
    this.element = ele
    this.priority = priority
  }
  // PriorityQueue的属性
  this.items = []
  // PriorityQueue的插入方法
  PriorityQueue.prototype.enqueue = function (ele, priority) {
    const queue_element = new QueueElement(ele, priority)
    // 当队列为空的时候，直接把元素进行插入
    if (this.items.length === 0) {
      this.items.push(queue_element)
      console.log(this.items)
    } else {
      // 队列不为空则比较优先级再进行插入
      const items_length = this.items.length
      let added = false
      for (let i = 0; i < items_length; i++) {
        // 数字越小，优先级越大，此时如果
        if (queue_element.priority < this.items[i].priority) {
          this.items.splice(i, 0, queue_element)
          // 如果插入了就不用继续循环了，直接跳出循环,同时把added开关由关变开,说明有元素插入进来了。
          added = true
          break
        }
      }
      // 如果没有数据插入到队列中，说明该数据优先级很低，这时直接插入到队列尾部
      if (!added) {
        this.items.push(queue_element)
        added = false
      }
    }
  }
  PriorityQueue.prototype.dequeue = function () {
    return this.items.shift()
  }
  PriorityQueue.prototype.front = function () {
    return this.items[0]
  }
  PriorityQueue.prototype.isEmpty = function () {
    return this.items.length == 0
  }
  PriorityQueue.prototype.size = function () {
    return this.items.length
  }
  PriorityQueue.prototype.toString = function () {
    let str = ''
    for (let i = 0; i < this.items.length; i++) {
      str += this.items[i] + ','
    }
    return str
  }
}
```



### 4.5 队列在前端的相关用途

队列在前端的相关用途：JS中的任务队列。



## 五、链表

### 5.1 理解链表

> l由若干个结点链结成一个链表，称之为`链式存储结构`。

在JS中用`对象Object`模拟链表：

```js
// 1.在JS中是没有链表这种数据结构的，那么只能用Object来模拟链表
const a = { val: 'a' }
const b = { val: 'b' }
const c = { val: 'c' }
const d = { val: 'd' }
a.next = b
b.next = c
c.next = d
console.log(a)
```

结果图：

![image-20210806231326505](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210806231326505.png)

相当于：

![image-20210806231856376](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210806231856376.png)



### 5.2 数组和链表的比较

**一、理解数组和链表的内存空间情况：**

- 数组需要一块`连续的内存空间`来存储数据，对内存的要求比较高。
- 而链表却相反，它并不需要一块连续的内存空间。链表是==通过指针将一组零散的内存块串联在一起==。

**二、数组结构擅长查询，但不擅长插入和删除：**

- 由于内存存储特性，数组可以实现快速的查找元素，但是在插入和删除时就需要移动大量的元素。原因就在于相邻元素在内存中的位置也是紧挨着的，中间没有空隙，因此就无法快速添加元素。而当删除后，内存空间中就会留出空隙，自然需要弥补。

**三、链表结构擅长插入和删除，但不擅长查找：**

- 由于链表是通过指针将各内存块串联了起来，使得==链表查找一个位置的元素时，都需要从头开始访问==。
- 链表在`插入和删除`数据时，`时间复杂度`可以达到O(1)，相当于数组效率很高。

**四、总结：**

- 数组：增删非首尾元素时往往需要移动元素。
- 链表：增删非首位元素，不需要移动元素，只需要更改`next`的指向即可。



### 5.3 







### 5.6 双向链表

![image-20210808215719490](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210808215719490.png)



## 六、哈希表

### 6.1 认识哈希表

哈希表是一种非常重要的数据结构，几乎所有的编程语言都直接或者间接应用这种数据结构。

==哈希表通常是基于数组实现的==，但是相对于数组，它存在更多优势：

- 哈希表可以提供非常快速的 **插入-删除-查找** 操作。
- 无论多少数据，插入和删除值都只需接近常量的时间，即 **O(1)** 的时间复杂度。实际上，只需要几个机器指令即可完成。
- 哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。
- 哈希表相对于树来说编码要简单得多。

**哈希表同样存在不足之处：**

- 哈希表中的数据是没有顺序的，所以不能以一种固定的方式（比如从小到大 ）来遍历其中的元素。
- 通常情况下，哈希表中的 `key` 是不允许重复的，不能放置相同的 `key`，用于保存不同的元素。



### 6.2 哈希表是什么

1. 哈希表并不好理解，不像数组、链表和树等可通过图形的形式表示其结构和原理。
2. 哈希表的结构就是数组，但它**神奇之处在于对`下标值`的一种变换**，这种变换我们可以称之为**哈希函数**，通过哈希函数可以获取 `HashCode`。

通过案例了解哈希表：

>- 案例一：公司想要存储 1000 个人的信息，每一个工号对应一个员工的信息。若使用数组，增删数据时比较麻烦；使用链表，获取数据时比较麻烦。有没有一种数据结构，能把某一员工的姓名转换为它对应的工号，再根据工号查找该员工的完整信息呢？没错此时就可以使用哈希表的哈希函数来实现。
>
>- 案例二：存储联系人和对应的电话号码：当要查找张三（比如）的号码时，若使用数组：由于不知道存储张三数据对象的下标值，所以查找起来十分麻烦，使用链表时也同样麻烦。而使用哈希表就能通过哈希函数把张三这个名称转换为它对应的下标值，再通过下标值查找效率就非常高了。

也就是说：==哈希表最后还是基于数据来实现的，只不过**哈希表能够通过哈希函数把字符串转化为对应的下标值，建立字符串和下标值的映射关系。**==



### 6.3 认识哈希化

为了把字符串转化为对应的下标值，需要有一套编码系统，为了方便理解我们创建这样一套编码系统：比如 a 为 1，b 为 2，c 为 3，以此类推 z 为 26，空格为 27（不考虑大写情况）。

有了编码系统后，将字母转化为数字也有很多种方案：

>**方案一：数字相加：**
>
>- 例如 cats 转化为数字：`3 + 1 + 20 + 19 = 43`，那么就把 43 作为 cats 单词的下标值储存在数组中；
>- 但是这种方式会存在这样的问题：很多的单词按照该方式转化为数字后都是 43（==即很容易产生相同的下标值==），比如 was。而在数组中一个下标值只能储存一个数据，所以该方式不合理。
>
>**方案二：幂的连乘：**
>
>- 我们平时使用的大于 10 的数字，就是用幂的连乘来表示它的唯一性的。 比如： `6543 = 6 * 10^3 + 5 * 10^2 + 4 * 10 + 3`；这样单词也可以用该种方式来表示：`cats = 3 * 27^3 + 1 * 27^2 + 20 * 27 + 17 = 60337`。
>- 虽然该方式可以保证字符的唯一性，但是如果是较长的字符（如 aaaaaaaaaa）所表示的数字就非常大，此时要求很大容量的数组。然而这样做会出现==许多下标值指向的是无效的数据（比如不存在 zxcvvv 这样的单词）==，从而造成了数组空间的浪费。

**两套方案的总结：**

- 第一套方案（让数字相加求和）产生的数组下标太少，同时产生相同下标值的概率又大。
- 第二套方案（与27的幂连乘相加求和）产生的数组下标太多，容易造成数组空间的浪费。

第二套方案相比于第一套来说，效果显然更好。那有没有一种`压缩方法`，把幂的连乘相加方案得到的**巨大整数范围压缩到可接受的数组范围中。**

答案是有的：可以通过`取余`操作来实现。虽然`取余`操作得到的结构也有可能重复，但是可以通过其他方式解决。



### 6.4 哈希表的一些概念

一、`哈希化`

- 将**大的数字**转化成**数组范围内的下标值**，这个过程就是哈希化。

二、`哈希函数`

- 将字符串转化为大数字，再把大数字进行哈希化的代码实现放在一个函数中，这个函数就是哈希函数。

三、`哈希表`

- 对最终数据插入到数组中，这个数组再进行整个结构的封装，得到的就是哈希表。



### 6.5 地址冲突

在实际中，**经过哈希函数哈希化过后得到的`下标值`可能有重复，这种情况称为冲突**。冲突是不可避免的，我们只能解决冲突。

解决冲突常见的两种方案：`链地址法（拉链法）`和`开放地址法`。

#### 6.5.1 链地址法

如下图所示，我们将每一个数字对10进行取余操作，则余数的范围0~9作为数组的下标值。并且，数组每一个下标值对应的位置存储的不再是一个数字，而是==**取余操作后相同余数的数字组成的数组或链表**。==

![image-20210814212513637](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210814212513637.png)

这样可以根据下标值获取到整个数组或链表，之后继续在数组或链表中查找就可以了。而且，产生冲突的元素一般不会太多。

**总结：**

>- 链地址法解决冲突的办法是每个数组单元中存储的不再是单个数据，而是一条链条。
>
>- 这条链条常使用的数据结构为`数组`或`链表`，两种数据结构查找的效率相当（因为链条的元素一般不会太多）。

#### 6.5.2 开放地址法

开放地址法的主要工作方式是寻找空白的单元格来放置冲突的数据项。

![image-20210814213925492](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210814213925492.png)

根据`探测空白位置`的方式不同，这里又有几种方案：

- **线性探测**
- **二次探测**
- **再哈希法**



##### 一、线性探测

- 当插入 13 时：

经过哈希化（对 10 取余）之后得到的下标值 index=3，但是该位置已经放置了数据 33。而线性探测就是从 index 位置+1 开始向后一个一个来查找合适的位置来放置 13，所谓合适的位置指的是空的位置，如上图中 index=4 的位置就是合适的位置。

- 当查询 13 时：
  - 首先 13 经过哈希化得到 index=3，如果 index=3 的位置存放的数据与需要查询的数据 13 相同，就直接返回； 不相同时，则线性查找，从 index+1 位置开始一个一个位置地查找数据 13。
  - 查询过程中不会遍历整个哈希表，只要查询到空位置，就停止，因为插入 13 时不会跳过空位置去插入其他位置。
- 当删除 13 时：
  - 删除操作和上述两种情况类似，但需要注意的是，删除一个数据项时，不能将该位置下标的内容设置为 null，否则会影响到之后其他的查询操作，因为一遇到为 null 的位置就会停止查找。
  - 通常删除一个位置的数据项时，我们可以将它进行特殊处理（比如设置为-1），这样在查找时遇到-1 就知道要继续查找。

线性探测存在的问题：

- 线性探测存在一个比较严重的问题，就是==**聚集**==。
- 如哈希表中还没插入任何元素时，插入 23、24、25、26、27，这就意味着下标值为 3、4、5、6、7 的位置都放置了数据，这种一连串填充单元就称为聚集。
- 聚集会影响哈希表的性能，无论是插入/查询/删除都会影响。
- 比如插入 13 时就会发现，连续的单元 3~7 都不允许插入数据，并且在插入的过程中需要经历多次这种情况。

![image-20210814224127155](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210814224127155.png)

>**因为==聚焦==这个问题，二次探测法可以解决。**

##### 二、二次探测

上文所说的线性探测存在的问题：

- 如果之前的数据是连续插入的，那么新插入的一个数据可能需要探测很长的距离；

  二次探测是在线性探测的基础上进行了优化：

- 线性探测：我们可以看成是步长为 1 的探测，比如从下表值 x 开始，那么线性探测就是按照下标值：x+1、x+2、x+3 等依次探测；

- 二次探测：对步长进行了优化，比如从下标值 x 开始探测：x+1^2^、x+2^2^、x+3^3^ 。这样一次性探测比较长的距离，避免了数据聚集带来的影响。

- 二次探测存在的问题：

  当插入数据分布性较大的一组数据时，比如：13-163-63-3-213，这种情况会造成步长不一的一种聚集（虽然这种情况出现的概率较线性探测的聚集要小），同样会影响性能。

##### 三、再哈希法

在开放地址法中寻找空白单元格的最好的解决方式为再哈希化。

- 二次探测的步长是固定的：1，4，9，16 依次类推。
- 现在需要一种方法：产生一种依赖关键字(数据)的探测序列，而不是每个关键字探测步长都一样。
- 这样，不同的关键字即使映射到相同的数组下标，也可以使用不同的探测序列。
- ==再哈希法的做法为：把关键字用另一个哈希函数，再做一次哈希化，用这次哈希化的结果作为该关键字的步长。==

第二次哈希化需要满足以下两点：

- 和==**第一个哈希函数不同**==，不然哈希化后的结果仍是原来位置；
- 不能输出为 0，否则每次探测都是原地踏步的死循环；

**优秀的哈希函数：**

>- stepSize = constant - （key % constant）；
>- 其中 constant 是质数，且小于数组的容量；
>- 例如：stepSize = 5 - （key % 5），满足需求，并且结果不可能为 0；

哈希化的效率

哈希表中执行插入和搜索操作效率是非常高的。

- 如果没有发生冲突，那么效率就会更高；
- 如果发生冲突，存取时间就依赖后来的探测长度；
- 平均探测长度以及平均存取时间，取决于`装填因子`，随着装填因子变大，探测长度会越来越长。

**装填因子:**

- 装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值；

  ```js
  //比如一个哈希表的长度为10（以数组模拟开放地址法）
  const arr=[1,2,3,4,5,6,7,8,9,10]
  //在这个哈希表中已经存放了6个数据项目，那空白的位置就只剩下4个。
  //那么这个装填因子就是6/10.
  ```

- 装填因子 = 总数据项 / 哈希表长度；

- 开放地址法的装填因子最大为 1，因为只有空白的单元才能放入元素；

- 链地址法的装填因子可以大于 1，因为只要愿意，拉链法可以无限延伸下去；

**不同探测方式性能的比较：**

- 线性探测

  可以看到，随着装填因子的增大，平均探测长度呈指数形式增长，性能较差。实际情况中，最好的装填因子取决于存储效率和速度之间的平衡，随着装填因子变小，存储效率下降，而速度上升。

![image-20210814230209870](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210814230209870.png)

- 二次探测和再哈希化的性能

  二次探测和再哈希法性能相当，它们的性能比线性探测略好。由下图可知，随着装填因子的变大，平均探测长度呈指数形式增长，需要探测的次数也呈指数形式增长，性能不高。

  ![image-20210814230306769](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210814230306769.png)

- 链地址法的性能

  可以看到随着装填因子的增加，平均探测长度呈线性增长，较为平缓。在开发中使用链地址法较多，比如 Java 中的 HashMap 中使用的就是链地址法。

  ![image-20210814230408203](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210814230408203.png)



### 6.6 哈希函数

哈希表的优势在于它的速度，所以哈希函数不能采用消耗性能较高的复杂算法。

**提高速度的一个方法是在哈希函数中尽量减少乘法和除法。**

性能高的哈希函数应具备以下两个优点：

- 快速的计算；
- 均匀的分布；

**一、快速计算：**

霍纳法则：在中国霍纳法则也叫做秦久韶算法，具体算法为：

![image-20210814230914275](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210814230914275.png)

求多项式的值时，首先计算最内层括号内一次多项式的值，然后由内向外逐层计算一次多项式的值。这种算法把求 n 次多项式 f(x)的值就转化为求 n 个一次多项式的值。

- 变换之前：
  - 乘法次数：n(n+1)/2 次；
  - 加法次数：n 次；
- 变换之后：
  - 乘法次数：n 次；
  - 加法次数：n 次；

如果使用大 O 表示时间复杂度的话，直接从变换前的 O(N^2)降到了 O(N)。

**二、均匀分布：**

在设计哈希表时，我们已经有办法处理映射到相同下标值的情况：`链地址法`或者`开放地址法`。

但是，为了提供效率，最好的情况还是让数据在哈希表中均匀分布。因此，我们==需要在使用常量的地方，尽量使用质数==。比如：`哈希表的长度`、`N 次幂的底数等`。

Java 中的 HashMap 采用的是链地址法，哈希化采用的是公式为：`index = HashCode(key) & (Length-1)` 即将数据化为二进制进行与运算，而不是取余运算。这样计算机直接运算二进制数据，效率更高。

==**但是 JavaScript 在进行较大数据的与运算时会出现问题，所以我们使用 JavaScript 实现哈希化时采用取余运算。**==



## 七、封装哈希表

### 7.1 哈希表常见操作

- `put(key, value)` 插入或修改操作。
- `get(key)` 获取哈希表中特定位置的元素。
- `remove(key)` 删除哈希表中特定位置的元素。
- `isEmpty()` 如果哈希表中不包含任何元素，返回 `trun`，如果哈希表长度大于 0 则返回 `false`。
- `size()` 返回哈希表包含的元素个数。
- `resize(value)` 对哈希表进行扩容操作。

### 7.2 哈希函数的简单实现

首先使用霍纳法则计算 hashCode 的值，通过取余操作实现哈希化，此处先简单地指定数组的大小。

```js
hashFun(string, size = 7) {
  // 先定义hashcode的值为0
  let hashcode = 0
  // 定义一个质数
  const Prime = 37
  for (const item of string) {
    hashcode = hashcode * Prime + item.charCodeAt()
  }
  // 对 hashCode 取余，然后就可以获取元素的下标值，并返回
  const index = hashcode % size
  return index
}
```

哈希函数测试：

```js
console.log(hashFun('abc')) //4
console.log(hashFun('cba')) //3
console.log(hashFun('mba')) //1
console.log(hashFun('nba')) //5
```

### 7.3 哈希表的实现

#### 7.3.1 创建哈希表类

封装的哈希表的数据结构模型：

![image-20210816013840589](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210816013840589.png)

**注意：**

>- 由于`storage`里面存放的是一系列的小数组，这些小数组里面才是存放真正的key/value。
>- 所有可以把这里相识的结构转化为`Map`字典数据类型。如下图所示：
>
>![image-20210816014139354](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210816014139354.png)

首先创建哈希表类 HashTable，并添加必要的属性和上面实现的哈希函数，再进行其他方法的实现。

```js
class HashTable {
  constructor() {
    // 属性
    this.storage = [] //哈希表存储数据的变量
    this.count = 0 //哈希表当前存放元素的个数
    this.limit = 7 //哈希表的长度（初始值设为质数7）
  }
  // 方法
  // 1、获取字符串在数组范围内下标值的哈希函数
  hashFun(string, size = 7) {
    // 先定义hashcode的值为0
    let hashcode = 0
    // 定义一个质数
    const Prime = 37
    for (const item of string) {
      hashcode = hashcode * Prime + item.charCodeAt()
    }
    // 获取下标值
    const index = hashcode % size
    return index
  }
}
```



#### 7.3.2 put(key,value)

`put(key,value)：`

哈希表的插入和修改操作是同一个函数：因为，当使用者传入一个 `[key, value]` 时，如果原来不存在该 key，那么就是插入操作，如果原来已经存在该 key，那么就是修改操作。原因是**Map数据结构不能出现重复的key(键值)。**

![image-20210816014533432](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210816014533432.png)

**实现思路：**

- 首先，根据 `ke`y 获取索引值 `index`，目的为将数据插入到 storage 的对应位置；
- 然后，根据索引值取出` bucket`，如果` bucket `不存在，先创建 bucket，随后放置在该索引值的位置；
- 接着，判断新增还是修改原来的值。如果已经有值了，就修改该值；如果没有，就执行后续操作。
- 最后，进行新增数据操作。

**代码实现：**

```js
// 2.插入或修改操作
put(key, value) {
  // 1.首先获取元素在数组范围内的下标值
  const index = this.hashFun(key, this.limit)
  // 2.在storage中取中相应下标值的bucket
  let bucket = this.storage[index]
  // 3.判断该下标值的bucket是否存在,如果不存在则创建一个新bucket
  if (bucket === undefined) {
    bucket = new Map()
    this.storage[index] = bucket
  }
  // 4.判断是插入操作还是修改操作
  if (bucket.has(key)) {
    // 判断是否存在该值，存在则修改它。
    bucket.set(key, value)
  } else {
    // 如果不存在则进行插入操作
    bucket.set(key, value)
    this.count++
  }
  // 5.判断是否扩容
  if (this.count > this.limit * 0.75) {
    const newSize = this.limit * 2
    // 5.1扩容到最新的质数
    const newPrime = this.getPrime(newSize)
    // 5.2哈希表进行扩容的调整
    this.resize(newPrime)
  }
}
```



#### 7.3.3 get(key)

**实现思路：**

- 首先，根据 key 通过哈希函数获取它在 `storage` 中对应的索引值 `index`。
- 然后，根据索引值获取对应的 `bucket`。
- 接着，判断获取到的 `bucket` 是否为 `null`，如果为 `null`，直接返回 `null`。
- 随后，线性遍历 `bucket` 中每一个 `key` 是否等于传入的 `key`。如果等于，直接返回对应的 `value`。
- 最后，遍历完 `bucket` 后，仍然没有找到对应的 `key`，直接 `return null` 即可。

**代码实现：**

```js
// 3.获取哈希表特定位置的元素
get(key) {
  // 1.获取元素在storage的下标
  const index = this.hashFun(key, this.limit)
  const bucket = this.storage[index]
  // 2.判断该位置是否有bucket，如果没有就直接返回null
  if (bucket === undefined) return null
  // 3.判断某个键是否在当前的Map字典数据结构中
  if (bucket.has(key)) {
    // 通过get(key)方法可以读取key对应的键值。
    return bucket.get(key)
  } else {
    return null
  }
}
```



#### 7.3.4 remove(key)

**实现思路：**

- 首先，根据 key 通过哈希函数获取它在 `storage` 中对应的索引值 `index`。
- 然后，根据索引值获取对应的 `bucket`。
- 接着，判断获取到的 `bucket` 是否为 `null`，如果为 `null`，直接返回 `null`。
- 随后，线性查找 `bucket`，寻找对应的数据，并且删除。
- 最后，依然没有找到，返回 `null`。

**代码实现：**

```js
remove(key) {
  // 1.获取哈希表在storage的下标值
  const index = this.hashFun(key, this.limit)
  let bucket = this.storage[index]
  let result = undefined
  // 2.判断该位置是否有bucket，如果没有就直接返回null
  if (bucket === undefined) return null
  // 3.如果有则移除该键对应的值。
  for (const item of bucket) {
    if (bucket.get(key) === item[1]) {
      // 保存要删除的键
      result = item
      // 删除该键
      bucket.delete(key)
      // 如果当前的bucket的size为0说明该bucket桶为空了，这时要把它变为undefined。
      // 原因是为了不影响前面判断桶是否存在
      if (bucket.size === 0) {
        this.storage[index] = undefined
      }
      this.count--
      break
    }
  }
  // 4.根据装填因子的大小，判断是否要进行哈希表压缩
  // 哈希表容器的长度不能太小（一般是不低于一开始设置的哈希表长度）
  if (this.limit > 7 && this.count < this.limit * 0.25) {
    const newSize = Math.floor(this.limit / 2)
    const newPrime = this.getPrime(newSize)
    this.resize(newPrime)
  }
  return result
}
```



#### 7.3.5 isEmpty()

```js
isEmpty() {
  return this.count === 0
}
```

#### 7.3.6 size()

```js
size() {
  return this.count;
}
```



### 7.4 哈希表的扩容与压缩

#### 7.4.1 为什么需要扩容

为什么需要扩容？

- 前面我们在哈希表中使用的是长度为 7 的数组，由于使用的是链地址法，装填因子(loadFactor)可以大于 1，所以这个哈希表可以无限制地插入新数据。
- 但是，随着数据量的增多，storage 中每一个 `index` 对应的 `bucket` 数组（链表）就会越来越长，这就会造成哈希表效率的降低。

什么情况下需要扩容？

- 常见的情况是 `this.count/this.limit > 0.75` 的时候进行扩容**（即装填因子>0.75的时候）。**

如何进行扩容？

- 简单的扩容可以直接扩大两倍（关于质数，之后讨论）。
- 扩容之后所有的数据项都要进行同步修改。

**扩容实现思路：**

- 首先，定义一个变量，比如 oldStorage 指向原来的 `storage`。
- 然后，创建一个新的容量更大的数组，让 `this.storage` 指向它。
- 最后，将 oldStorage 中的每一个 bucket 中的每一个数据取出来依次添加到 `this.storage` 指向的新数组中。

![image-20210816015443121](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210816015443121.png)



#### 7.4.2 resize() 的实现

装填因子 = 哈希表中数据 / 哈希表长度即（ `this.count/this.limit` ）

**代码实现：**

resize 方法，既可以实现哈希表的扩容，也可以实现哈希表容量的压缩。

```js
// 9.resize(value) 重新调整哈希表大小，扩容或压缩
resize(newLimit) {
  // 1.进行扩容操作的时候，要把原来的storage璃的所有数据都保存起来
  const oldStorage = this.storage
  // 2.重置this.storage
  this.storage = []
  this.count = 0
  this.limit = newLimit //哈希表的新长度
  // 3、遍历 oldStorage，取出所有数据，重新 put 到 this.storage
  for (const bucket of oldStorage) {
    // 3.1 如果存在bucket，则把bucket里的数据都重新put到新的this.storage
    if (bucket) {
      for (const item of bucket) {
        this.put(item[0], item[1])
      }
    }
  }
}
```

- 通常情况下当装填因子 `装填因子> 0.75` 时，对哈希表进行扩容。在哈希表中的添加方法（push 方法）中添加如下代码，判断是否需要调用扩容函数进行扩容。

  ```js
  // 5.判断哈希表是否要扩容，若装填因子 > 0.75，则扩容
  if (this.count > this.limit * 0.75) {
    const newSize = this.limit * 2
    // 5.1扩容到最新的质数
    const newPrime = this.getPrime(newSize)
    // 5.2哈希表进行扩容的调整
    this.resize(newPrime)
  }
  ```

- 当装填因子 `装填因子 < 0.25` 时，对哈希表容量进行压缩。在哈希表中的删除方法（remove 方法）中添加如下代码，判断是否需要调用扩容函数进行压缩。

  ```js
  // 4.判断是否缩小哈希表容器
  // 哈希表容器的长度不能太小（一般是不低于一开始设置的哈希表长度）
  if (this.limit > 7 && this.count < this.limit * 0.25) {
    const newSize = Math.floor(this.limit / 2)
    const newPrime = this.getPrime(newSize)
    this.resize(newPrime)
  }
  ```

#### 7.4.3 选择质数作为哈希表容量

**实现思路：**

2 倍扩容或压缩之后，通过循环调用 `isPrime` 判断得到的容量是否为质数，不是则+1，直到是为止。比如原长度：7，2 倍扩容后长度为 14，14 不是质数，`14 + 1 = 15` 不是质数，`15 + 1 = 16` 不是质数，`16 + 1 = 17` 是质数，停止循环，由此得到质数 17。

- 第一步：首先需要为 HashTable 类添加判断质数的 `isPrime` 方法和获取质数的 `getPrime` 方法：

  ```js
  // 7.判断是否是质数
  isPrime(number) {
    if (number <= 1 || number === 4) return false
    // Math.ceil() 函数返回大于或等于一个给定数字的最小整数。
    // 比如Math.ceil(2.4) ==>返回的结果就是3
    const temp = Math.ceil(Math.sqrt(number))
    for (let i = 2; i < temp; i++) {
      if (number % i === 0) return false
    }
    return true
  }
  
  // getPrime(number) 根据传入的 number 获取最临近的质数
  getPrime(num) {
    // num不是质数，则一直加，加到最临近的质数
    while (!this.isPrime(num)) {
      num++
    }
    return num
  }
  ```

- 第二步：修改添加元素的 `put` 方法和删除元素的 `remove` 方法中关于数组扩容的相关操作：

  扩容：

  ```js
  if (this.count > this.limit * 0.75) {
    const newSize = this.limit * 2
    // 5.1扩容到最新的质数
    const newPrime = this.getPrime(newSize)
    // 5.2哈希表进行扩容的调整
    this.resize(newPrime)
  }
  ```

  压缩：

  ```js
  if (this.limit > 7 && this.count < this.limit * 0.25) {
    const newSize = Math.floor(this.limit / 2)
    const newPrime = this.getPrime(newSize)
    this.resize(newPrime)
  }
  ```



### 7.5 哈希表的完整实现

```js
class HashTable {
  constructor() {
    // 属性
    this.storage = [] //哈希表存储数据的变量
    this.count = 0 //哈希表当前存放元素的个数
    this.limit = 7 //哈希表的长度（初始值设为质数7）
  }
  // 方法
  // 1、获取字符串在数组范围内下标值的哈希函数
  hashFun(string, size = 7) {
    // 先定义hashcode的值为0
    let hashcode = 0
    // 定义一个质数
    const Prime = 37
    for (const item of string) {
      hashcode = hashcode * Prime + item.charCodeAt()
    }
    // 获取下标值
    const index = hashcode % size
    return index
  }
  // 2.插入或修改操作
  put(key, value) {
    // 1.首先获取元素在数组范围内的下标值
    const index = this.hashFun(key, this.limit)
    // 2.在storage中取中相应下标值的bucket
    let bucket = this.storage[index]
    // 3.判断该下标值的bucket是否存在,如果不存在则创建一个新bucket
    if (bucket === undefined) {
      bucket = new Map()
      this.storage[index] = bucket
    }
    // 4.判断是插入操作还是修改操作
    if (bucket.has(key)) {
      // 判断是否存在该值，存在则修改它。
      bucket.set(key, value)
    } else {
      // 如果不存在则进行插入操作
      bucket.set(key, value)
      this.count++
    }
    // 5.判断哈希表是否要扩容，若装填因子 > 0.75，则扩容
    if (this.count > this.limit * 0.75) {
      const newSize = this.limit * 2
      // 5.1扩容到最新的质数
      const newPrime = this.getPrime(newSize)
      // 5.2哈希表进行扩容的调整
      this.resize(newPrime)
    }
  }
  // 3.获取哈希表特定位置的元素
  get(key) {
    // 1.获取元素在storage的下标
    const index = this.hashFun(key, this.limit)
    const bucket = this.storage[index]
    // 2.判断该位置是否有bucket，如果没有就直接返回null
    if (bucket === undefined) return null
    // 3.判断某个键是否在当前的Map字典数据结构中
    if (bucket.has(key)) {
      // 通过get(key)方法可以读取key对应的键值。
      return bucket.get(key)
    } else {
      return null
    }
  }
  // 4.remove(key)
  remove(key) {
    // 1.获取哈希表在storage的下标值
    const index = this.hashFun(key, this.limit)
    let bucket = this.storage[index]
    let result = undefined
    // 2.判断该位置是否有bucket，如果没有就直接返回null
    if (bucket === undefined) return null
    // 3.如果有则移除该键对应的值。
    for (const item of bucket) {
      if (bucket.get(key) === item[1]) {
        // 保存要删除的键
        result = item
        // 删除该键
        bucket.delete(key)
        // 如果当前的bucket的size为0说明该bucket桶为空了，这时要把它变为undefined。
        // 原因是为了不影响前面判断桶是否存在
        if (bucket.size === 0) {
          this.storage[index] = undefined
        }
        this.count--
        break
      }
    }
    // 4.判断是否缩小哈希表容器
    // 哈希表容器的长度不能太小（一般是不低于一开始设置的哈希表长度）
    if (this.limit > 7 && this.count < this.limit * 0.25) {
      const newSize = Math.floor(this.limit / 2)
      const newPrime = this.getPrime(newSize)
      this.resize(newPrime)
    }
    return result
  }
  // 5.isEmpty()方法
  isEmpty() {
    return this.count === 0
  }
  // 6.size()
  size() {
    return this.count
  }
  // 7.判断是否是质数
  isPrime(number) {
    if (number <= 1 || number === 4) return false
    // Math.ceil() 函数返回大于或等于一个给定数字的最小整数。
    // 比如Math.ceil(2.4) ==>返回的结果就是3
    const temp = Math.ceil(Math.sqrt(number))
    for (let i = 2; i < temp; i++) {
      if (number % i === 0) return false
    }
    return true
  }
  // 8.获取质数
  getPrime(num) {
    // num不是质数，则一直加，加到最临近的质数
    while (!this.isPrime(num)) {
      num++
    }
    return num
  }
  // 9.resize(value) 重新调整哈希表大小，扩容或压缩
  resize(newLimit) {
    // 1.进行扩容操作的时候，要把原来的storage璃的所有数据都保存起来
    const oldStorage = this.storage
    // 2.重置this.storage
    this.storage = []
    this.count = 0
    this.limit = newLimit //哈希表的新长度
    // 3、遍历 oldStorage，取出所有数据，重新 put 到 this.storage
    for (const bucket of oldStorage) {
      // 3.1 如果存在bucket，则把bucket里的数据都重新put到新的this.storage
      if (bucket) {
        for (const item of bucket) {
          this.put(item[0], item[1])
        }
      }
    }
  }
}
```



## 八、树

### 8.1 树结构

#### 8.1.1 树结构对比于数组/链表/哈希表有哪些优势呢？

数组：

- 优点：可以通过下标值快速查询数据，访问效率高。
- 缺点：在插入和删除元素时，需要大量的位移操作；查找数据时需要先对数据进行排序，生成有序数组，才能提高查找效率；

链表：

- 优点：数据的插入和删除操作效率很高。
- 缺点：查找效率低，需要从头开始依次查找，直到找到目标数据为止；当需要在链表中间位置插入或删除数据时，插入或删除的效率都不高。

哈希表：

- 优点：哈希表的插入/查询/删除效率都非常高；

- 缺点：空间利用率不高，底层使用的数组中很多单元没有被利用；并且哈希表中的元素是无序的，不能按照固定顺序遍历哈希表中的元素；而且不能快速找出哈希表中最大值或最小值这些特殊值。

树结构：

- 优点：树结构结合了上述三种结构的优点，同时弥补了它们的缺点（效率不一定比它们高）。

**总的来说，每种数据结构都有自己特定的应用场景。**



#### 8.1.2 认识树结构

**树的常用术语：**

![image-20210818211712669](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210818211712669.png)

- 节点的度：节点的子树个数，比如上图的`节点B`的度为2，`节点D`的度为1，`节点H`的度为0。
- 树的度：树中的所有节点中最大的度数，比如上图中`树的度为2`（因为所有的节点中度最大为2）。
- 叶子节点：节点的度为0即叶子节点。比如上图中的H、I、J、E、G即叶子节点。
- 父节点：度不为0的节点称为父节点，如上图节点 B 是节点 D 和 E 的父节点。
- 子节点：若 B 是 D 的父节点，那么 D 就是 B 的子节点；
- 兄弟节点（Sibling）：具有同一父节点的各节点彼此是兄弟节点，比如上图的 B 和 C，D 和 E 互为兄弟节点；
- 路径和路径长度：路径指的是一个节点到另一节点的通道，路径所包含边的个数称为路径长度，比如 A->H 的路径长度为 3；
- 节点的层次（Level）：规定根节点在 1 层，其他任一节点的层数是其父节点的层数加 1。如 B 和 C 节点的层次为 2；
- 树的深度（Depth）：树种所有节点中的最大层次是这棵树的深度，如上图树的深度为 4；



#### 8.1.3 树结构表示方法

**一、最普通的表示方法：**

![image-20210818212939550](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210818212939550.png)

如上图所示：树结构的组成方式很像链表，都是由一个个节点连接而成的。只不过它每个父节点的子节点数量不同。

==但是这种表示方法有个缺点，就是在每个节点不能确定有多少个引用数量。==

**二、儿子-兄弟表示法：**

![image-20210818213241222](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210818213241222.png)

这种表示方法可以完整地记录每个节点的数据，比如：

```js
//节点A
Node{
  //存储数据
  this.data = data
  //统一只记录左边的子节点
  this.leftChild = B
  //统一只记录右边的第一个兄弟节点
  this.rightSibling = null
}

//节点B
Node{
  this.data = data
  this.leftChild = E
  this.rightSibling = C
}

//节点F
Node{
  this.data = data
  this.leftChild = null
  this.rightSibling = null
}
```

这种表示法的优点在于每一个节点中引用的数量都是确定的。

**三、儿子-兄弟表示法旋转：**

以下为儿子-兄弟表示法组成的树结构：

![image-20210818224353865](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210818224353865.png)

将其顺时针旋转 45° 之后：

![image-20210818224424314](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210818224424314.png)

这样就成为了一棵二叉树，由此我们可以得出结论：==**任何一棵树结构都可以通过二叉树进行模拟。**==



### 8.2 二叉树

#### 8.2.1 二叉树的概念

如果树中的每一个节点最多只能由两个子节点，这样的树就称为二叉树；

#### 8.2.2 二叉树的组成

- 二叉树可以为空，也就是没有节点；
- 若二叉树不为空，则它由根节点和其左子树 TL 和右子树 TR 的两个不相交的二叉树组成；

#### 8.2.3 二叉树的五种形态

![image-20210818231540345](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210818231540345.png)

上图分别表示：空的二叉树、只有一个节点的二叉树、只有左子树 TL 的二叉树、只有右子树 TR 的二叉树和有左右两个子树的二叉树。

#### 8.2.4 二叉树的特性

- 一个二叉树的第 i 层的最大节点树为：2^(i-1)^，（i>=1）

- 深度为 k 的二叉树的最大节点总数为：2^k^ - 1 ，k >= 1；

- 对任何非空二叉树，若 n~~0~~ 表示`叶子节点的个数`，n~~2~~表示度为 2 的`非叶子节点个数`，那么两者满足关系：n~~0~~ = n~~2~~ + 1；如下图所示：H，E，I，J，G 为叶子节点，总数为 5；A，B，C，F 为度为 2 的非叶子节点，总数为 4；满足 n~~0~~ = n~~2~~ + 1 的规律。

![image-20210818231917942](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210818231917942.png)

#### 8.2.5 特殊的二叉树

**一、完美二叉树：**

完美二叉树（Perfect Binary Tree）也成为满二叉树（Full Binary Tree），在二叉树中，除了最下一层的叶子节点外，每层节点都有 2 个子节点，这就构成了完美二叉树。

![image-20210818232051271](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210818232051271.png)

**二、完全二叉树：**

- 除了二叉树最后一层外，其他各层的节点数都达到了最大值；
- 并且，最后一层的叶子节点从左向右是连续存在，只缺失右侧若干叶子节点；
- 完美二叉树是特殊的完全二叉树；

![image-20210818232257746](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210818232257746.png)

上图中，由于D缺失了右子节点，所以这棵树是完全二叉树。

#### 8.2.6 二叉树的数据存储

常见的二叉树存储方式为数组和链表：

**一、使用数组：**

- 完全二叉树：按从上到下，从左到右的方式存储数据。

![image-20210818232522549](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210818232522549.png)

使用数组存储时，取数据的时候也十分方便：`左子节点的序号等于父节点序号 *2`，`右子节点的序号等于父节点序号 *2 + 1 `。

- 非完全二叉树：非完全二叉树需要转换成完全二叉树才能按照上面的方案存储，这样会浪费很大的存储空间。

![image-20210818232704770](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210818232704770.png)

**二、使用链表：**

二叉树最常见的存储方式为链表：每一个节点封装成一个 Node，Node 中包含存储的数据、左子节点的引用和右子节点的引用。

![image-20210818232806100](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210818232806100.png)



### 8.3 二叉搜索树

#### 8.3.1 理解二叉搜索树

二叉搜索树（BST，Binary Search Tree），也称为二叉排序树和二叉查找树。

二叉搜索树是一棵二叉树，可以为空。

如果不为空，则满足以下性质：

- 条件 1：非空左子树的所有键值小于其根节点的键值。比如三中节点 6 的所有非空左子树的键值都小于 6；
- 条件 2：非空右子树的所有键值大于其根节点的键值；比如三中节点 6 的所有非空右子树的键值都大于 6；
- 条件 3：左、右子树本身也都是二叉搜索树；

![image-20210818233116733](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210818233116733.png)

如上图所示，树二和树三符合 3 个条件属于二叉树，树一不满足条件 3 所以不是二叉树。

**总结：**

- 二叉搜索树的特点主要是较小的值总是保存在左节点上，相对较大的值总是保存在右节点上。
- 这种特点使得二叉搜索树的查询效率非常高，这也就是二叉搜索树中“搜索”的来源。

#### 8.3.2 二叉搜索树应用举例

下面是一个二叉搜索树：

![image-20210818233400516](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210818233400516.png)

若想在其中查找数据 10，只需要查找 4 次，查找效率非常高。

- 第 1 次：将 10 与根节点 9 进行比较，由于 10 > 9，所以 10 下一步与根节点 9 的右子节点 13 比较；
- 第 2 次：由于 10 < 13，所以 10 下一步与父节点 13 的左子节点 11 比较；
- 第 3 次：由于 10 < 11，所以 10 下一步与父节点 11 的左子节点 10 比较；
- 第 4 次：由于 10 = 10，最终查找到数据 10 。

![image-20210818233502687](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210818233502687.png)

同样是 15 个数据，在排序好的数组中查询数据 10，需要查询 10 次：

![image-20210818233536281](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210818233536281.png)

其实：如果是排序好的数组，可以通过二分查找：第一次找 （15+1）/2向上取整为8，第二次找 （8+15）/2向上取整为12，第三次找 0。我们发现如果把每次二分的数据拿出来以树的形式表示的话就是二叉搜索树。这就是数组二分法查找效率之所以高的原因。

### 8.4 二叉搜索树的封装

二叉搜索树有四个最基本的属性：`指向节点的根（root）`，`节点中的键（key）`、`左指针（right）`、`右指针（right）`。

![image-20210818234049500](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210818234049500.png)

所以，二叉搜索树中除了定义 root 属性外，还应定义一个节点内部类，里面包含每个节点中的 left、right 和 key 三个属性。

```javascript
// 声明一个二叉搜索树BinarySearchTree类
function BinarySearchTree() {
  // 属性
  this.root = null
  // 内部节点类
  function Node(key) {
    this.key = key
    this.left = null
    this.right = null
  }
}
```

### 8.5 二叉搜索树的常见操作

- `insert(key)` 向树中插入一个新的键。
- `search(key)` 在树中查找一个键，如果节点存在，则返回 true；如果不存在，则返回 `false`。
- `preOrderTraverse` 通过先序遍历方式遍历所有节点。
- `inOrderTraverse` 通过中序遍历方式遍历所有节点。
- `postOrderTraverse` 通过后序遍历方式遍历所有节点。
- `min` 返回树中最小的值/键。
- `max` 返回树中最大的值/键。
- `remove(key)` 从树中移除某个键。

#### 8.5.1 插入数据

实现思路：

- 首先根据传入的 key 创建节点对象。
- 然后判断根节点是否存在，不存在时通过：this.root = newNode，直接把新节点作为二叉搜索树的根节点。
- 若存在根节点则重新定义一个内部方法 `insertNode()` 用于查找插入点。

```js
BinarySearchTree.prototype.insertNode = function (root, node) {
  // console.log(root.key, node.key)
  if (root.key > node.key) {
    // consooe.log(root.val, node.val)
    // 1.左子节点插入
    if (root.left === null) {
      // root.left作为递归调用的基线条件
      // 1.1如果当前的根节点的左子节点指向null，则直接插入
      root.left = node
    } else {
      // 1.2否则递归调用自己
      root = root.left
      this.insertNode(root, node)
    }
  } else {
    // console.log(root.val, node.val)
    // 2.右子节点插入
    if (root.right === null) {
      // 2.1如果右子节点指向为空，则说明是该树的叶子节点，这样直接插入
      root.right = node
    } else {
      root = root.right
      // 2.2 否则递归调用自己，直到找到叶子节点
      this.insertNode(root, node)
    }
  }
}


// insert(key)：向树中插入一个新的键。
BinarySearchTree.prototype.insert = function (key) {
  const node = new Node(key)
  if (this.root === null) {
    // 1.如果该树为空则直接插入
    this.root = node
  } else {
    // 2.否则调用insertNode(root,node)
    this.insertNode(this.root, node)
  }
}
```



#### 8.5.2 遍历数据

这里所说的树的遍历不仅仅针对二叉搜索树，而是适用于所有的二叉树。由于树结构不是线性结构，所以遍历方式有多种选择，常见的三种二叉树遍历方式为：

- 先序遍历；
- 中序遍历；
- 后序遍历；

还有层序遍历，使用较少。

##### 先序遍历

**口诀：**

>- 先访问根节点
>- 对根节点的左子树进行先序遍历
>- 对根节点的右子树进行先序遍历

![image-20210820035555719](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210820035555719.png)

**代码实现：**

```js
// preOrderTraverse()：通过先序遍历方式遍历所有节点。
// 先序遍历：口诀：根左右
// 1.间接调用preOrderTraverseNode()方法，实现间接调用递归
BinarySearchTree.prototype.preOrderTraverse = function (callback) {
  this.preOrderTraverseNode(this.root, callback)
}
// 1.1 先序遍历树中各节点的方法
BinarySearchTree.prototype.preOrderTraverseNode = function (
node,
 callback
) {
  if (node !== null) {
    // 1.2 打印该节点的值
    callback(node.key)
    this.preOrderTraverseNode(node.left, callback)
    this.preOrderTraverseNode(node.right, callback)
  }
}
```



##### 中序遍历

**口诀：**

>- 对根节点的左子树进行中序遍历。
>- 访问根节点
>- 对根节点的右子树进行中序遍历。

![image-20210820035834782](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210820035834782.png)

**代码实现：**

```js
// inOrderTraverse()：通过中序遍历方式遍历所有节点。
// 1.中序遍历 ：口诀：左根右
BinarySearchTree.prototype.inOrderTraverse = function (callback) {
  this.inOrderTraverseNode(this.root, callback)
}
// 2.中序遍历树中的各节点
BinarySearchTree.prototype.inOrderTraverseNode = function (
node,
 callback
) {
  // 3.如果当前节点不为空，则递归继续找，直到找到符号条件的叶子节点
  if (node !== null) {
    // 3.1 递归调用，继续中序遍历左子树
    this.inOrderTraverseNode(node.left, callback)
    // 3.2 访问当前根节点的值。
    callback(node.key)
    // 3.3 递归调用，继续中序遍历有右子树
    this.inOrderTraverseNode(node.right, callback)
  }
}
```



##### 后序遍历

**口诀：**

>- 对根节点的左子树进行后序遍历
>- 对根节点的右子树进行后序遍历
>- 访问根节点

![image-20210820040019034](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210820040019034.png)

**代码实现：**

```js
// postOrderTraverse()：通过后序遍历方式遍历所有节点。
// 后序遍历
BinarySearchTree.prototype.postOrderTraverse = function (callback) {
  this.postOrderTraverseNode(this.root, callback)
}
// 后续遍历树中各节点
BinarySearchTree.prototype.postOrderTraverseNode = function (
node,
 callback
) {
  // 1.如果当前节点不为空，则继续查找
  if (node !== null) {
    // 1.1 递归调用，继续后续遍历左子树
    this.postOrderTraverseNode(node.left, callback)
    // 1.2 递归调用，继续后续遍历右子树
    this.postOrderTraverseNode(node.right, callback)
    // 1.3 访问当前根节点的值
    callback(node.key)
  }
}
```



#### 8.5.3 查找数据

**查找最大值或最小值**

在二叉搜索树中查找最值非常简单，最小值在二叉搜索树的最左边，最大值在二叉搜索树的最右边。只需要一直向左/右查找就能得到最值，如

![image-20210820040201513](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210820040201513.png)

**代码实现：**

```js
// 搜索最大值
// max()方法搜索最大值
BinarySearchTree.prototype.max = function (node) {
  // 1.如果当前树为空树直接返回null
  if (!this.root) return null
  let maxKey = undefined
  while (node !== null) {
    // 1.因为最大值永远在二叉搜索树的右子树的右节点
    maxKey = node.key
    node = node.right
  }
  return maxKey
}

// 搜索最小值
// min()方法搜索最小值
BinarySearchTree.prototype.min = function (node) {
  // 1.如果当前树为空树直接返回null
  if (!this.root) return null
  let minKey = undefined
  while (node !== null) {
    // 1.因为最小值永远在二叉搜索树的右子树的右节点
    minKey = node.key
    node = node.left
  }
  return minKey
}
```



#### 8.5.4 查找特定值

查找二叉搜索树当中的特定值效率也非常高。只需要从根节点开始将需要查找节点的 key 值与之比较，若 node.key < root 则向左查找，若 node.key > root 就向右查找，直到找到或查找到 null 为止。这里可以使用递归实现，也可以采用循环来实现。

**代码实现：**==这里我采用循环来实现==

```js
// search(key)` 在树中查找一个键，如果节点存在，则返回 true；如果不存在，则返回 `false。
BinarySearchTree.prototype.search = function (key) {
  if (key === 'undefined') throw new Error('缺少参数key')
  // 1.如果当前为空树，直接返回false
  if (this.root === null) {
    return false
  } else {
    let current = this.root
    while (current !== null) {
      // 2.如果要查找的key值小于当前节点key值，则往左子树方向查找
      if (current.key > key) {
        current = current.left
      } else if (current.key < key) {
        // 3.如果要查找的key值大于当前节点key值，则往右子树方向查找
        current = current.right
      } else {
        // 4.相等则说明找到了
        return true
      }
    }
    // 5.最后查找还是为null，则说明查找到叶子节点都没查到到相关key值的节点。
    return false
  }
}
```



#### 8.5.5 删除数据

**实现思路：**

>- 第一步：先找到需要删除的节点，若没找到，则不需要删除；
>
>- 第二步：删除找到的指定节点，后分 3 种情况：
>  - 删除的是叶子节点；
>  - 删除的是只有一个子节点的节点；
>  - 删除的是有两个子节点的节点；

##### 步骤一：查找要删除的节点

首先定义变量 `currentNode` 用于保存需要删除的节点、变量 `parentNode` 用于保存它的父节点、变量 `isLeftChild` 保存 current 是否为 parent 的左节点，这样方便之后删除节点时改变相关节点的指向。

```js
// 定义currentNode和parentNode这两个变量存储地址的思路是从链表那来，即双指针保存前后地址数据。
let currentNode = this.root //用来存储当前节点的地址。
let parentNode = null //用来存储父节点的地址。
let isLeftChild = true //用来判断当前子节点是否是父节点的左子节点
// 第一步：先找到需要删除的节点，如果找不到则返回false.
// 1.先判断当前节点的key值是否与查找的key相等
while (currentNode.key !== key) {
  // parentNode变量保存currentNode节点的地址，即该变量是保存当前节点的后一个节点的地址。
  parentNode = currentNode
  // 1.1 如果当前节点为空，说明该树是空树或者是没有该key值的节点
  if (currentNode === null) return false
  // 1.2 如果查找的key小于当前的节点的key值，说明要查找的节点在左子树方位
  if (key < currentNode.key) {
    isLeftChild = true
    currentNode = currentNode.left
  } else {
    // 1.3 如果查找的key大于当前的节点的key值，说明要查找的节点在右子树方位。
    isLeftChild = false
    currentNode = currentNode.right
  }
}
```

##### 步骤二：分情况讨论删除节点

**一、删除的是叶子节点**

>删除的是叶子节点分两种情况：
>
>- 情况一：叶子节点也是根节点。
>
>  当该叶子节点为根节点时，如下图所示，此时 `currentNode == this.root`，直接通过：`this.root = null`，删除根节点。
>
>  ![image-20210820041116862](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210820041116862.png)
>
>- 情况二：叶子节点不为根节点
>
>  当该叶子节点不为根节点时也有两种情况，如下图所示：
>
>  ![image-20210820042349676](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210820042349676.png)
>
>  若 current = 8，可以通过：parent.left = null，删除节点 8；
>
>  若 current = 10，可以通过：parent.right = null，删除节点 10；

**代码实现：**

```js
// 2.判断是否是叶子节点
if (currentNode.left === null && currentNode.right === null) {
  // 2.1 如果删除的当前节点的左子节点和右子节点都指向为null，说明该节点是二叉搜索树的叶子节点
  if (currentNode === this.root) {
    // 2.1.1 判断删除的节点是否是二叉搜索树中的根节点，并且该树有且只有一个根节点
    this.root = null //删除该根节点直接将它指向null
  } else if (isLeftChild) {
    // 2.1.2 判断是否是左子节点
    parentNode.left = null
  } else {
    // 2.1.3 判断是否是右子节点
    parentNode.right = null
  }
```



**二、删除的只有一个子节点的节点**

>**有六种情况：**
>
>当 current 存在左子节点时（current.right == null）：
>
>- 情况 1：current 为根节点（current == this.root），如节点 11，此时通过：this.root = current.left，删除根节点 11；
>
>- 情况 2：current 为父节点 parent 的左子节点（isLeftChild == true），如节点 5，此时通过：parent.left = current.left，删除节点 5；
>
>- 情况 3：current 为父节点 parent 的右子节点（isLeftChild == false），如节点 9，此时通过：parent.right = current.left，删除节点 9；
>
>  ![image-20210820042645952](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210820042645952.png)
>
>当 current 存在右子节点时（current.left = null）：
>
>- 情况 4：current 为根节点（current == this.root），如节点 11，此时通过：this.root = current.right，删除根节点 11。
>
>- 情况 5：current 为父节点 parent 的左子节点（isLeftChild == true），如节点 5，此时通过：parent.left = current.right，删除节点 5；
>
>- 情况 6：current 为父节点 parent 的右子节点（isLeftChild == false），如节点 9，此时通过：parent.right = current.right，删除节点 9；
>
>  ![image-20210820042727282](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210820042727282.png)

**代码实现：**

```js
} else if (currentNode.right === null) {
  // 3.1判断该二叉搜索树是否是只有一个左子节点的根节点
  if (currentNode === this.root) {
    this.root = currentNode.left
    // 3.2 判断当前要删除的节点是父节点的左子节点
  } else if (isLeftChild) {
    // 3.2.1 如果是左子节点
    parentNode.left = currentNode.left
  } else {
    // 3.2.2 如果是右子节点
    parentNode.right = currentNode.left
  }
  // 4.判断删除的当前节点只有一个右子节点。即该节点度为1
} else if (currentNode.left === null) {
  // 4.1 判断该二叉搜索树是否是只有一个右子节点的根节点
  if (currentNode === this.root) {
    this.root = currentNode.right
    // 4.2判断当前要删除的节点是父节点的右节点
  } else if (isLeftChild) {
    // 4.2.1 如果要删除的节点是父节点的左子节点
    parentNode.left = currentNode.right
  } else {
    // 4.2.2 如果要删除的节点是父节点的右子节点
    parentNode.right = currentNode.right
  }
}
```



**三、删除的是有两个子节点的节点**

规律总结：如果要删除的节点有两个子节点，甚至子节点还有子节点，这种情况下需要从要删除节点下面的子节点中找到一个合适的节点，来替换当前的节点。

若用 `currentNode`表示需要删除的节点，则合适的节点指的是：

- `currentNode` 左子树中比 `currentNode`小一点点的节点，即 `currentNode` 左子树中的最大值；
- `currentNode` 右子树中比 `currentNode`大一点点的节点，即 `currentNode` 右子树中的最小值；

>==前驱&后继==
>
>在二叉搜索树中，这两个特殊的节点有特殊的名字：
>
>- 比 `currentNode` 小一点点的节点，称为`currentNode`节点的前驱。比如下图中的节点 5 就是节点 7 的前驱；
>
>- 比 `currentNode`大一点点的节点，称为 `currentNode` 节点的后继。比如下图中的节点 8 就是节点 7 的后继；
>
>  ![image-20210820043154453](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210820043154453.png)
>
>总结：
>
>**查找需要被删除的节点 currentNode 的后继时，需要在 currentNode 的右子树中查找最小值，即在 currentNode 的右子树中一直向左遍历查找；**
>
>**查找前驱时，则需要在 currentNode 的左子树中查找最大值，即在 currentNode 的左子树中一直向右遍历查找。**

下面只讨论查找 current 后继的情况，查找前驱的原理相同，这里暂不讨论。

**代码实现：**

```js
// 5.删除的当前节点右两个子节点。利用当前要删除的节点的前驱或后继解决。
} else {
  // 5.1找前驱或后继(这里我找后继)，即删除的当前节点的右子树中最小key值的节点，让后这个节点替换被删除的节点
  let replaceNode = currentNode.right //replaceNode即要替换要删除的节点的最小子节点
  let prevReplaceNode = currentNode //最小子节点的前一个节点
  // 5.2 判断是否找到最小节点，没找到继续循环找
  while (replaceNode.left !== null) {
    prevReplaceNode = replaceNode
    replaceNode = replaceNode.left
  }
  // 5.3 如果找到后继最小节点，还要继续判断是否是删除节点的直接右子节点.
  if (replaceNode !== currentNode.right) {
    // 5.3.1 如果不是则按情况处理
    prevReplaceNode.left = replaceNode.right //有些情况是最小节点会右右子节点，此时要把该右子节点的地址要给最小节点的前一各节点向左保存起来，起到连接效果
    replaceNode.right = currentNode.right //最小节点向右连接原来要删除节点的右子节点的地址
  }
  replaceNode.left = currentNode.left //最小节点向左连接删除节点的左子树地址

  // 5.4 判断删除节点是否是该二叉平衡树的根节点
  if (currentNode === this.root) {
    // 5.4.1 如果是则直接将根节点指向替换的节点
    this.root = replaceNode

    //5.4.2 判断删除节点是否是父节点的左子节点
  } else if (isLeftChild) {
    parentNode.left = replaceNode
  } else {
    parentNode.right = replaceNode
  }
}
```



#### 8.5.6 删除数据的完整实现过程

```js
// 删除节点
// remove(key)方法
BinarySearchTree.prototype.remove = function (key) {
  // 定义currentNode和parentNode这两个变量存储地址的思路是从链表那来，即双指针保存前后地址数据。
  let currentNode = this.root //用来存储当前节点的地址。
  let parentNode = null //用来存储父节点的地址。
  let isLeftChild = true //用来判断当前子节点是否是父节点的左子节点
  // 第一步：先找到需要删除的节点，如果找不到则返回false.
  // 1.先判断当前节点的key值是否与查找的key相等
  while (currentNode.key !== key) {
    // parentNode变量保存currentNode节点的地址，即该变量是保存当前节点的后一个节点的地址。
    parentNode = currentNode
    // 1.1 如果当前节点为空，说明该树是空树或者是没有该key值的节点
    if (currentNode === null) return false
    // 1.2 如果查找的key小于当前的节点的key值，说明要查找的节点在左子树方位
    if (key < currentNode.key) {
      isLeftChild = true
      currentNode = currentNode.left
    } else {
      // 1.3 如果查找的key大于当前的节点的key值，说明要查找的节点在右子树方位。
      isLeftChild = false
      currentNode = currentNode.right
    }
  }
  // 第二步：进行删除节点操作；注意这里删除节点右三种情况：
  // ——第一种：删除的节点是二叉搜索树的叶子节点
  // ——第二种：删除的节点是只有一个子节点的节点，即删除的节点度为1
  // ——第三种：删除的节点是右两个子节点的节点，即删除的节点度为2
  // 2.判断是否是叶子节点
  if (currentNode.left === null && currentNode.right === null) {
    // 2.1 如果删除的当前节点的左子节点和右子节点都指向为null，说明该节点是二叉搜索树的叶子节点
    if (currentNode === this.root) {
      // 2.1.1 判断删除的节点是否是二叉搜索树中的根节点，并且该树有且只有一个根节点
      this.root = null //删除该根节点直接将它指向null
    } else if (isLeftChild) {
      // 2.1.2 判断是否是左子节点
      parentNode.left = null
    } else {
      // 2.1.3 判断是否是右子节点
      parentNode.right = null
    }

    // 3.判断删除的当前节点只有一个子左节点。即该节点度为1
  } else if (currentNode.right === null) {
    // 3.1判断该二叉搜索树是否是只有一个左子节点的根节点
    if (currentNode === this.root) {
      this.root = currentNode.left
      // 3.2 判断当前要删除的节点是父节点的左子节点
    } else if (isLeftChild) {
      // 3.2.1 如果是左子节点
      parentNode.left = currentNode.left
    } else {
      // 3.2.2 如果是右子节点
      parentNode.right = currentNode.left
    }
    // 4.判断删除的当前节点只有一个右子节点。即该节点度为1
  } else if (currentNode.left === null) {
    // 4.1 判断该二叉搜索树是否是只有一个右子节点的根节点
    if (currentNode === this.root) {
      this.root = currentNode.right
      // 4.2判断当前要删除的节点是父节点的右节点
    } else if (isLeftChild) {
      // 4.2.1 如果要删除的节点是父节点的左子节点
      parentNode.left = currentNode.right
    } else {
      // 4.2.2 如果要删除的节点是父节点的右子节点
      parentNode.right = currentNode.right
    }

    // 5.删除的当前节点右两个子节点。利用当前要删除的节点的前驱或后继解决。
  } else {
    // 5.1找前驱或后继(这里我找后继)，即删除的当前节点的右子树中最小key值的节点，让后这个节点替换被删除的节点
    let replaceNode = currentNode.right //replaceNode即要替换要删除的节点的最小子节点
    let prevReplaceNode = currentNode //最小子节点的前一个节点
    // 5.2 判断是否找到最小节点，没找到继续循环找
    while (replaceNode.left !== null) {
      prevReplaceNode = replaceNode
      replaceNode = replaceNode.left
    }
    // 5.3 如果找到后继最小节点，还要继续判断是否是删除节点的直接右子节点.
    if (replaceNode !== currentNode.right) {
      // 5.3.1 如果不是则按情况处理
      prevReplaceNode.left = replaceNode.right //有些情况是最小节点会右右子节点，此时要把该右子节点的地址要给最小节点的前一各节点向左保存起来，起到连接效果
      replaceNode.right = currentNode.right //最小节点向右连接原来要删除节点的右子节点的地址
    }
    replaceNode.left = currentNode.left //最小节点向左连接删除节点的左子树地址

    // 5.4 判断删除节点是否是该二叉平衡树的根节点
    if (currentNode === this.root) {
      // 5.4.1 如果是则直接将根节点指向替换的节点
      this.root = replaceNode

      //5.4.2 判断删除节点是否是父节点的左子节点
    } else if (isLeftChild) {
      parentNode.left = replaceNode
    } else {
      parentNode.right = replaceNode
    }
  }
}
```



### 8.6 二叉搜索树深度/广度搜索

#### 8.6.1 深度优先搜索

深度优先搜索是，先搜索完某子树的左节点，再搜索右节点。

```js
##树的情况一：
const tree = {
  val: 'A',
  left: {
    val: 'B',
    left: {
      val: 'D',
    },
    right: {
      val: 'E',
    },
  },
  right: {
    val: 'C',
    left: {
      val: 'F',
    },
    right: {
      val: 'G',
    },
  },
}

## 树的情况二
const tree1 = {
  val: 'A',
  children: [
    {
      val: 'B',
      children: [
        { val: 'D', children: [] },
        { val: 'E', children: [] },
      ],
    },
    {
      val: 'c',
      children: [
        { val: 'F', children: [] },
        { val: 'G', children: [] },
      ],
    },
  ],
}
```

**递归版本：**

```js
##针对树情况一：深度优先搜索（递归版本）
const depthFirstSearch1 = root => {
  if (!root) return
  console.log(root.val)
  depthFirstSearch1(root.left)
  depthFirstSearch1(root.right)
}
depthFirstSearch1(tree)

##针对树情况二：深度优先搜索（递归版本）
const depthFirstSearch2 = root => {
  if (!root) return
  console.log(root.val)
  // 遍历每个节点的children
  root.children.forEach(item => {
    depthFirstSearch2(item)
  })
}
console.log('----------------------')
depthFirstSearch2(tree1)
```

**非递归版本：**自己模拟压栈。

> 思路：先将右节点压栈，再左节点压栈

```js
const dfs3 = root => {
  if (!root) return
  // 1. 定义一个栈
  const stack = []
  // 2.搜先把头节点压入栈里面去
  stack.push(root)
  // 3.当栈不为空依次进行压栈和出栈行为，直到栈为空
  while (stack.length !== 0) {
    // 3.0每循环一次就出栈一个节点
    root = stack.pop()
    // 3.1 跳出就打印
    console.log(root.val)

    // 压栈顺序是先右后左
    // 3.2 如果弹出的节点有右孩子，则将其右孩子压栈
    if (root.right) {
      stack.push(root.right)
    }
    // 3.3 如果弹出的节点有左孩子，则将其左孩子压栈
    if (root.left) {
      stack.push(root.left)
    }
  }
}
```



#### 8.6.2 广度优先搜索

广度优先搜索就是把每一个子树的左子节点和右子节点搜索出来，直到结束。

做法思路：利用栈。

```js
const bfs = root => {
  if (!root) return
  const queue = []
  queue.push(root)
  // 当队列不为空的时候，循环将节点出栈和进栈
  while (queue.length !== 0) {
    root = queue.shift()
    // 出队列打印
    console.log(root.val)
    // 如果有左孩子则先将左孩子进队列
    if (root.left) {
      queue.push(root.left)
    }
    // 如果有右孩子则先将右孩子进队列
    if (root.right) {
      queue.push(root.right)
    }
  }
}
bfs(tree) //=>结果：A B C D E F G
```



### 8.7 二叉搜索树的先中后序遍历

```js
##树结构
const tree = {
  val: 'A',
  left: {
    val: 'B',
    left: {
      val: 'D',
      left: null,
      right: null,
    },
    right: {
      val: 'E',
      left: null,
      right: null,
    },
  },
  right: {
    val: 'C',
    left: {
      val: 'F',
      left: null,
      right: null,
    },
    right: {
      val: 'G',
      left: null,
      right: null,
    },
  },
}

## 辅助函数
let res = ''
const print = val => {
  res += val + ' '
}
```

#### 8.7.1 先序遍历

先序遍历指的是：**对于所有子树来说，都是先打印头节点，再打印左子树的所有节点，再打印右子树的所有节点**

**==总结：根、左、右。==**

**递归版本：**

```js
const preSearch = head => {
  if (head) {
    console.log(head.val)
    preSearch(head.left)
    preSearch(head.right)
  }
}
preSearch(tree)
```

**非递归版本：**

先序遍历 利用栈，思路是先将根节点压入栈中，然后弹出打印，并且检测是否还孩子节点，有就压入栈中。

```js
const dgpreSearch = (head, print) => {
  if (head) {
    const stack = [head]
    while (stack.length) {
      head = stack.pop()
      print(head.val)
      if (head.right) {
        stack.push(head.right)
      }
      if (head.left) {
        stack.push(head.left)
      }
    }
  }
}
```



#### 8.7.2 中序遍历

中序遍历指的是：**对于所有子树来说，都是先打印左子树的所有节点，再打印头节点，最后打印右子树的所有节点。**

**递归版本：**

```js
const inSearch = head => {
  if (head) {
    inSearch(head.left)
    console.log(head.val)
    inSearch(head.right)
  }
}
```

**非递归版本：**

思路：

>1. 对于每棵树的左边界，都压入栈中。
>2. 然后弹出栈顶的节点并且打印。
>3. 在弹出节点的过程中还要对该弹出节点检查是有右孩子，如果有右孩子，则压进栈中。
>4. 重复上面的操作

```js
const dginSearch = (head, print) => {
  // 如果根节点不为空，则进行中序遍历
  if (head) {
    const stack = []
    // 当栈不为空或者有节点(不指向null),则进行while压栈出栈，直到这个条件为fasle则说明中序遍历结束
    while (stack.length || head) {
      // 先把树的左边界全部压入栈中
      if (head) {
        stack.push(head)
        head = head.left
      } else {
        // 如果左边界全部进栈了，则开始弹出栈顶元素并且查看是否有右孩子，右则压入栈中，然后重复上述操作
        head = stack.pop()
        // 弹出就打印
        print(head.val)
        head = head.right
      }
    }
  }
}
```



#### 8.7.3 后序遍历

后序遍历指的是：**对于所有子树来说，都是先打印左子树的所有节点，再打印右子树的所有节点，最后打印头节点。**

**递归版本：**

```js
const postSearch = head => {
  if (head) {
    postSearch(head.left)
    postSearch(head.right)
    console.log(head.val)
  }
}
```

**非递归版本：**

思路：也是利用栈，不过需要两个栈，一个作为任务栈，另一个作为搜集栈。

>1. 先将根节点压入栈中。
>2. 任务栈的栈顶元素出栈，该元素出栈后被搜集栈搜集，也就是改元素被压入了搜集栈中。
>3. 检查任务栈出栈元素是否有左右孩子，如果有推入任务栈中（推入任务栈的顺序是左-右）
>4.  重复上面的操作,最后遍历

```js
const dgpostSearch = (head, print) => {
  if (head) {
    const stack1 = []
    const stack2 = []
    stack1.push(head)
    while (stack1.length) {
      head = stack1.pop()
      stack2.push(head)
      if (head.left) {
        stack1.push(head.left)
      }
      if (head.right) {
        stack1.push(head.right)
      }
    }
    // 将收集栈中的元素全部依次出栈，其出栈顺序就是后序遍历的顺序
    const length = stack2.length
    for (let i = 0; i < length; i++) {
      print(stack2.pop().val)
    }
  }
}
```



### 8.8 平衡树

暂时不学习。

## 九、图

### 9.1 图的基本概念

![image-20210821015410657](https://cdn.jsdelivr.net/gh/threey333/Picture/数据结构与算法/image-20210821015410657.png)



## 十、排序算法

### 10.1 冒泡排序

**思路：**

- 第一步用 `for` 循环控制冒泡范围。（因为每一次冒泡，最后一位的值都是最高的，所有每次冒泡范围都要 ==-1==。
- 第二步再内层 `for`循环进行数组中的每两个数比较大小，然后根据大小互换位置。

**代码：**

```js
//交换元素方法
function swap(arr, i, j) {
  ;[arr[i], arr[j]] = [arr[j], arr[i]]
}

const bubbleSort = arr => {
  if (arr === null || arr.length < 2) {
    return
  }
  const length = arr.length
  // 1.冒泡排序第一层for循环控制的是遍历范围
  // -第一次遍历范围length-1
  // -第一次遍历范围length-2
  for (let i = length - 1; i > 0; i--) {
    // 2.第二次for循环就是真正的数组中每两个元素的交换过程
    for (let j = 0; j < i; j++) {
      // 2.1 如果前面的小于后面的，则交换它们之间的位置
      if (arr[j] > arr[j + 1]) {
        swap(arr, j, j + 1)
      }
    }
  }
}

// 测试
const arr = [14, 245, 32, 21, 5, 75, 20, 4, 8, 3, 34, 3]
const arr1 = [8, 3, 6, 9, 10, 25, 41, 5, 3, 8, 8, 9, 0]
const arr2 = [2, 8, 52, 7, 5, 7, 1, 2, 12, 15, 1]
console.log('冒泡排序前', arr)
console.log('冒泡排序前', arr1)
console.log('冒泡排序前', arr2)
bubbleSort(arr)
bubbleSort(arr1)
bubbleSort(arr2)
console.log('冒泡排序后', arr) //[3, 3, 4, 5, 8, 14, 20, 21, 32, 34, 75, 245]
console.log('冒泡排序后', arr1) //[0, 3, 3, 5, 6, 8, 8, 8, 9, 9, 10, 25, 41]
console.log('冒泡排序后', arr2) //[1, 1, 2, 2, 5, 7, 7, 8, 12, 15, 52]
```

**冒泡排序时间复杂度和空间复杂度：**

>- 时间复杂度：O(N²)
>- 空间复杂度：O(1)
>- 稳定性：稳定



### 10.2 选择排序

**思路：**

- 第一步：先定义一个变量用来存放最小值的下标，这里默认指向数组第一个元素的位置。
- 第二步：然后遍历数组，找到数组中最小的值，然后记录该最小值的下标。
- 第三步：将找到的最小值下标位置和数组的第一个元素进行位置交换。
- 进行完第一轮后，该变量记录数组第二个元素的位置，然后重复第二步骤和第三步骤，最后依次重复一、二、三步骤。

**代码实现：**

```js
//交换元素方法
function swap(arr, i, j) {
  ;[arr[i], arr[j]] = [arr[j], arr[i]]
}

//选择排序方法
const selectSort = arr => {
  if (arr.length < 2 || arr === null) {
    return
  }
  const length = arr.length
  for (let i = 0; i < length - 1; i++) {
    //i~N-1位置上找
    // 1.先把元素的最小值标志在第一位置
    let minIndex = i
    // console.log(minIndex)
    // 2.再进行一次for循环找到数组中元素最小值的位置，即下标值
    for (let j = i + 1; j < length; j++) {
      //i~N-1位置上找
      // 2.1 循环中如果还有比minIndex位置的更小的元素，则把该最小元素的位置赋值给minIndex
      if (arr[minIndex] > arr[j]) {
        // 2.2 存在比minIndex小的元素，则把该新的最小元素位置的下标记录
        minIndex = j
      }
    }
    // 3.内部for循环完了，minIndex的下标值记录的就是数组中最小元素的下标，此时进行交换位置
    if (minIndex !== i) {
      swap(arr,i,minIndex)
    }
  }
}


//检测
const arr = [4, 1234, 23, 65, 568, 234, 54, 67, 1, 3, 6, 98, 3, 2]
console.log('选择排序前:', arr)
selectSort(arr)
console.log('选择排序后:', arr) // [1, 2, 3, 3, 4, 6, 23, 54, 65, 67, 98, 234, 568, 1234]
```

**选择排序的时间复杂度和空间复杂度：**

>- 时间复杂度：O(N²)
>- 空间复杂度：O(1)
>- 稳定性：不稳定
>
>**总结：**最没用的算法，花那么多时间还不稳定。



### 10.3 插入排序

**思路：**

-  第一步：从数组的第二个位置取一个数(即下标为1,同时默认下标0位置是有序的)，然后判断这个位置之前的元素是否有序(有序即1，2，3，4这样排列)
- 第二步：用当前的数依次一个一个的跟前面的元素比较，小于就交换位置，大于就不交换位置。
- 第三步：比较完后，当前的数就处在有序的位置上。然后继续选取下一个位置的数，依次重复上面1和2的操作

**代码实现：**

```js
function insertSort(arr) {
  if (arr === null || arr.length < 2) return
  const length = arr.length

  // 1. 0-0位置默认有序，所有从0-1开始选数比较
  for (let i = 1; i < length; i++) {
    // 1.1 上面for循环要处理边界问题
    // 2.从当前元素的位置往前判断元素是否有序，不是有序则进行调整
    for (let j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
      // 2.1 元素调整为有序位置
      ;[arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
    }
  }
}

//测试
const arr = [4, 1234, 23, 65, 568, 234, 54, 67, 1, 3, 6, 98, 3, 2]
const arr1 = [1, 4, 4, 3, 5, 6, 7, 7, 1, 2, 2, 10, 18]
console.log('插入排序前:', arr)
insertSort(arr)
insertSort(arr1)
console.log('插入排序后:', arr)
console.log('插入排序后:', arr1)  //[1, 1, 2, 2, 3, 4, 4, 5, 6, 7, 7, 10, 18]
```

**插入排序的时间复杂度和空间复杂度：**

>- 时间复杂度：O(N²)
>
>- 额外空间复杂度：O(1)
>- 稳定性：稳定



### 10.4 希尔排序

希尔排序是插入排序的改良版本。

**实现思路：**

- 第一步：采用希尔的间隔思路，用数组的长度/2作为数组中每个元素的之间的间隔。
- 第二步：每个间隔划分后，会形成多个小型数组，每个小数组中进行插入排序，调整元素位置为有序。
- 第三步：每个小数组插入排序完后，再把间隔/2，然后再进行步骤2的过程。
- 第四步：重复上面1、2步骤，直到间隔为1结束。

**代码实现：**

```js
function shellSort(arr) {
  if (arr === null || arr.length < 2) return
  const length = arr.length
  // 1.不断缩小划分间隔，直到间隔为1
  for (
    let interval = Math.floor(length / 2);
    interval > 0;
    interval = Math.floor(interval / 2)
  ) {
    // 2.以间隔为大小选择元素，即当层循环是选元素
    for (let i = interval; i < length; i++) {
      // 3.以选择元素的当前下标位置向前以间隔为大小查看是否有序，如果有序，则不用交换位置，如果无序，则交换位置
      for (
        let j = i - interval;
        j >= 0 && arr[j] > arr[j + interval];
        j -= interval
      ) {
        // 3.1 间隔大小之间的元素如果无序，进行位置交换
        ;[arr[j], arr[j + interval]] = [arr[j + interval], arr[j]]
      }
    }
  }
}


//测试
const arr = [4, 1234, 23, 65, 568, 234, 54, 67, 1, 3, 6, 98, 3, 2]
console.log('希尔排序前:', arr)
shellSort(arr)
console.log('希尔排序后:', arr) // [1, 2, 3, 3, 4, 6, 23, 54, 65, 67, 98, 234, 568, 1234]
```

**希尔排序的时间复杂度和空间复杂度：**

>- 



### 10.5 归并排序

归并排序需要用到递归。

这里我们先看一道递归题目。（**这道题的思路有助于我们理解归并排序算法**）

>求一个数组中，某个范围上的最大值，例如求arr[L...R]上的最大值

解决步骤：

```js
//思路，将数组拆分为一个个小数组，直到小数组的长度为1（从中点开始划分）
function scopeMax(arr, L, R) {
  // 1.如果数组为空，直接返回
  if (arr === null) return
  // 2.如果数组的长度为1，返回当前元素。
  if (L === R) {
    return arr[L]
  }
  // 3.获取中点
  let Mid = L + ((R - L) >> 1)
  // 4.递归调用scopeMax,直到将该数组分为一个个长度为1的小数组
  // 4.1先左划分
  let leftMax = scopeMax(arr, L, Mid)
  // 4.2 右划分
  let rightMax = scopeMax(arr, Mid + 1, R)
  // 5.当小数组长度为1，即L==R,返回当前元素，然后慢慢汇总比较，得出最大值
  return Math.max(leftMax, rightMax)
}

// 测试
const arr = [3, 1, 5, 3, 6, 8, 24, 2, 6, 14, 2, 7]
console.log(scopeMax(arr, 0, arr.length - 1)) //24
```



**归并排序实现思路：**

- 归并排序先从中点开始。
- 先左划分，直到数组只有一个元素的时候说明有序。
- 后右划分，直到数组只有一个元素的时候说明有序。
- 将这些拆分的数组进行有序排序合并。

**代码实现：**

```js
function mergerSort(arr, L, R) {
  if (arr === null || arr.length < 2) return
  if (L === R) return
  // 1.归并排序从中点开始
  let Mid = L + ((R - L) >> 1)
  // 2.先左划分,当数组只有一个元素的时候说明有序
  mergerSort(arr, L, Mid)
  // 3.后右划分，当数组只有一个元素的时候说明有序
  mergerSort(arr, Mid + 1, R)
  // 4.合并并且元素之间排好顺序
  merger(arr, L, Mid, R)
}
// 归并排序的合并方法
function merger(arr, L, M, R) {
  // 1.定义一个变量i,作为新数组的移动的下标
  let i = 0
  // 2.定义p1、p2两个指针，分别指向，数组arr的最左边，数组arr中点前一位
  p1 = L
  p2 = M + 1
  // 3.定义一个临时数组，作为临时存放元素排序后的数组，最后再把排序后的信息赋值给原数组arr
  let tempArr = []
  // 4.当左指针小于中点下标和右指针小于最右边时，即没越界，此时比较两边的元素大小，然后排序放到新数组里
  while (p1 <= M && p2 <= R) {
    // 4.1 当p1指针指向的元素小于p2指针指向的元素时,则把小的元素放到新的临时数组中
    tempArr[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++]
  }
  // 5.下面两个while循环只有一个会出现，即一个完成了，另一个还有元素没对比，此时应该把剩余的元素直接添加到数组中
  while (p1 <= M) {
    tempArr[i++] = arr[p1++]
  }
  while (p2 <= R) {
    tempArr[i++] = arr[p2++]
  }
  // 6.将排序好的数组，赋值给原数组
  const length = tempArr.length
  for (let i = 0; i < length; i++) {
    arr[L + i] = tempArr[i]
  }
}
```

**归并排序的时间复杂度和空间复杂度：**

>- 时间复杂度：O（N*logN）
>- 空间复杂度：O（N）
>- 稳定性：稳定



### 10.6 快速排序(重点)

再学习快速排序之前，首先看一个题目：

 >给定一个数组arr，和一个数num，请把小于num的数放到左边，大于num的数放到右边，等于num的数放到中间。

**解决思路：**

- 第一步：用一个变量作为<区域边界为-1，用另一个变量作为>区域边界为arr.length。
- 第二步：定义一个指针i,指向arr的第一个位置。
- 第三步（这一步是最重要的）：
  - 3.1 如果当前指针指向的数小于num，[i]和<区域的下一个数进行交换，<区域右扩一位，i+1。
  - 3.2 如果当前指针指向的数大于num，[i]和>区域的上一个数进行交换，>区域左扩一位，i保持不变。
  - 3.3 如果当前指针指向的数等于num，不进行位置交换，i+1。

**代码实现：**

```js
const arr = [3, 5, 6, 6, 3, 4, 5, 2, 6, 9, 0]
function fn1(arr, num) {
  // 1.定义一个变量i,这个变量作为一个数组指针，默认指向数组第一位
  let i = 0
  // 2.定义一个<区域的变量，默认是是数组最左边界外面
  let minLeft = -1
  // 3.定义一个>区域的变量，默认是数组最右边界外面
  let maxRight = arr.length
  // 4.进行判断
  while (i < maxRight) {
    if (arr[i] < num) {
      // 4.1 如果i指向的元素小于num,那么arr[i]与<区域的后一个元素进行交换，<区域右扩一位，i++
      ;[arr[i], arr[minLeft + 1]] = [arr[minLeft + 1], arr[i]]
      minLeft = minLeft + 1
      i = i + 1
      // 4.2 如果i指向的元素大于num,那么arr[i]与>区域的前一个元素进行交换，>区域左扩一位，i不变
    } else if (arr[i] > num) {
      ;[arr[i], arr[maxRight - 1]] = [arr[maxRight - 1], arr[i]]
      maxRight = maxRight - 1
    } else {
      i = i + 1
    }
  }
  return arr
}

console.log('结果:', fn1(arr, 4)) //[3, 0, 2, 3, 4, 5, 5, 6, 9, 6, 6]
```



> 基于荷兰国旗思路，我们是有可以基于它来实现快速排序的，其中只不过多了个递归，因为，我们将数划分好后，元素并没有有序排列。

**快速排序实现思路：**

- 先随机获取数组范围内的下标位置（公式:` L + Math.floor(Math.random() * (R - L + 1))`），然后与数组最后一个位置的元素进行元素交换。
- 跟荷兰国旗思路一样，用一个指针变量指向数组的第一个位置(==注意这个第一个位置并不是指向0，因为数组会被划分，左边界会发生变化==)
- 用 `left`作为<区域的左边界、`right` 作为>区域的右边界。
- 进行partition过程中，小于/大于对标元素的进行位置交换。
- 因为每次partition完后都会返回一个相同元素的左右范围边界的下标，所以利用这个关系不断的进行划分数组重复partition。**即每次进行排序，都要返回一个=区域的大小范围，有利于划分新的数组左右边界。**例如=[3,2,1,4,5,5,8,6,7]，这里新的两个数组的左右边界为:[0,3]、[6,8]，相同区域的左右范围边界下标为[4,5]
- 新数组进行递归，反复重复上面的操作。

**代码实现：**

```js
// 快速排序
class QuickSort {
  constructor() {}
  quickSort(arr) {
    if (arr === null || arr.length < 2) return
    this.process(arr, 0, arr.length - 1)
  }
  process(nums, L, R) {
    if (L < R) {
      // 在数组中随机选取一个数作为partition，即对标
      let partitionNumberIndex =
          L + Math.floor(Math.random() * (R - L + 1))
      // 然后跟数组的最后一个数进行交换
      this.swap(nums, partitionNumberIndex, R)
      // 每做完一次partition分类后，都会返回一组相同数数组的左右边界下标。
      // 例如[3,2,4,5,5,5,7,6,9,9],相同数组即[5,5,5]，即该数组的左右边界下标为[3,5]
      const sameArray_L_R_index = this.partition(nums, L, R)
      this.process(nums, L, sameArray_L_R_index[0] - 1)
      this.process(nums, sameArray_L_R_index[1] + 1, R)
    }
  }

  partition(nums, L, R) {
    let currentIndex = L //进行数组遍历的指针
    let left = L - 1 //定义'<'区域的坐标位置
    let right = R //定义'>'区域的坐标位置
    // 后面进行判断
    while (currentIndex < right) {
      if (nums[currentIndex] < nums[R]) {
        // 1.如果currentIndex指的元素小于对标元素，那么该currentIndex指的元素与'<'区域的下一个元素进行交换，然后'<'区域右扩一位，currenIndex加1
        this.swap(nums, ++left, currentIndex++)
      } else if (nums[currentIndex] > nums[R]) {
        // 2.如果currentIndex指的元素大于对标元素，那么该currentIndex指的元素与'>'区域的上一个元素进行交换，然后'>'区域左扩一位，currentIndex不变
        this.swap(nums, --right, currentIndex)
      } else {
        // 3.如果等于zecurrentIndex加1
        currentIndex++
      }
    }
    // 处理完之后，对标元素要跟right坐标上的元素进行交换
    this.swap(nums, right, R)
    // 返回相同区域的左右边界下标
    return [left + 1, right]
  }

  swap(nums, L, R) {
    ;[nums[L], nums[R]] = [nums[R], nums[L]]
  }
}
```

利用对数器进行验证测试：

```js
//实例一个快排对象
const quickSort = new QuickSort()

// 生成随机数组数据
const generateRandomArray = function (maxSize, maxValue) {
  const arr = new Array(Math.floor(Math.random() * (maxSize + 1)))
  for (let i = 0, length = arr.length; i < length; i++) {
    arr[i] =
      Math.floor((maxValue + 1) * Math.random()) -
      Math.floor(maxValue * Math.random())
  }
  return arr
}

// 对数器方法
const main = function (count, size, value) {
  let testTime = count
  let maxSize = size
  let maxValue = value
  let succeed = true
  for (let i = 0; i < testTime; i++) {
    let arr1 = generateRandomArray(maxSize, maxValue)
    let arr2 = JSON.parse(JSON.stringify(arr1)) //拷贝一份
    quickSort.quickSort(arr1)
    comparator(arr2)
    if (!(JSON.stringify(arr1) === JSON.stringify(arr2))) {
      succeed = false
      break
    }
  }
  console.log(succeed ? '排序正确！！！' : '排序错误!')
}

main(1000, 10, 10)
// 结果：排序正确！！！
```

**快速排序的时间复杂度和空间复杂度：**

>- 时间复杂度：O(N*logN)  
>- 空间复杂度：O(logN)
>- 稳定性：不稳定



### 10.7 堆排序

[堆排序超链接](#堆排序)



## 十一、堆和堆排序

### 11.1 堆结构

 堆结构是一颗 `完全二叉树`，同时堆又可以分为 `大根堆` 和 `小根堆` 。

- 大根堆：完全二叉树中如果每棵子树的最大值都在顶部。
- 小根堆：完全二叉树中如果每棵子树的最小值都在顶部。

> 优先级队列就是堆结构。



### 11.2 堆结构的向上堆化调整和向下堆化调整

一、向上堆化调整操作（heapInsert）：

```js
swap(arr, i, j) {
  ;[arr[i], arr[j]] = [arr[j], arr[i]]
}

// 向上堆化调整操作（heapInsert）
heapInsert(arr, index) {
  // 1.如果i的位置为0,说明在根中，那么不用调整
  if (index == 0) return
  // 2.获取父亲元素的下标位置
  let parentIndex = Math.floor((index - 1) / 2)
  // 3.父亲根孩子进行打擂台比较，孩子大，那么元素的位置进行交换，然后继续向上挑战。如果父亲大，则位置不变。
  while (arr[index] > arr[parentIndex]) {
    swap(arr, index, parentIndex)
    // 4.交换完位置后，孩子的下标位置变为父亲的下标位置，继续向上挑战
    index = parentIndex
    // 5.获取最新孩子的下标位置的父亲
    parentIndex = Math.floor((index - 1) / 2)
  }
}
```

二、向下堆化调整操作（heapify）：

```js
swap(arr, i, j) {
  ;[arr[i], arr[j]] = [arr[j], arr[i]]
}

// 向下堆化调整操作（heapify）
heapify(arr, index, heapSize) {
  // 1.获取左孩子
  let left = index * 2 + 1
  while (left < heapSize) {
    // 2.当有左孩子的时候再继续判断是否有右孩子，如果有右孩子则进行比较大小，选出最大的那个孩子的下标
    let largest =
        left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left

    //3.当拿到最大孩子，再根父亲进行比较,选出最大的那个人的下标
    largest = arr[index] > arr[largest] ? index : largest
    if (largest === index) {
      // 4.说明当前位置无需向下堆化调整，已是局部大根堆
      break
    }
    // 5.如果largest!==index,则先进行元素位置上的交换
    this.swap(arr, index, largest)
    // 6.当前index位置变为largest的下标位置
    index = largest
    // 7.再向下获取孩子进行堆化调整
    left = index * 2 + 1
  }
}
```



### 11.3 堆排序

堆排序就是由堆结构的两个堆化操作进行的排序：<a name='堆排序'></a>

```js
//堆类
class Heap {
  constructor() {}
  swap(arr, i, j) {
    ;[arr[i], arr[j]] = [arr[j], arr[i]]
  }
  //某元素现在所处的位置向上进行堆化调整
  heapInsert(arr, index) {
    // 1.如果i的位置为0,说明在根中，那么不用调整
    if (index == 0) return
    // 2.获取父亲元素的下标位置
    let parentIndex = Math.floor((index - 1) / 2)
    // 3.父亲根孩子进行打擂台比较，孩子大，那么元素的位置进行交换，然后继续向上挑战。如果父亲大，则位置不变。
    while (arr[index] > arr[parentIndex]) {
      swap(arr, index, parentIndex)
      // 4.交换完位置后，孩子的下标位置变为父亲的下标位置，继续向上挑战
      index = parentIndex
      // 5.获取最新孩子的下标位置的父亲
      parentIndex = Math.floor((index - 1) / 2)
    }
  }
  // 某元素现在所处的位置向下进行堆化调整
  heapify(arr, index, heapSize) {
    // 1.获取左孩子
    let left = index * 2 + 1
    while (left < heapSize) {
      // 2.当有左孩子的时候再继续判断是否有右孩子，如果有右孩子则进行比较大小，选出最大的那个孩子的下标
      let largest =
          left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left

      //3.当拿到最大孩子，再根父亲进行比较,选出最大的那个人的下标
      largest = arr[index] > arr[largest] ? index : largest
      if (largest === index) {
        // 4.说明当前位置无需向下堆化调整，已是局部大根堆
        break
      }
      // 5.如果largest!==index,则先进行元素位置上的交换
      this.swap(arr, index, largest)
      // 6.当前index位置变为largest的下标位置
      index = largest
      // 7.再向下获取孩子进行堆化调整
      left = index * 2 + 1
    }
  }

  //堆排序
  heapSort(arr) {
    if (arr == null || arr.length < 2) return
    const { length } = arr
    for (let i = arr.length - 1; i >= 0; i--) {
      this.heapify(arr, i, length)
    }
    let heapSize = length
    this.swap(arr, 0, --heapSize)
    while (heapSize > 0) {
      this.heapify(arr, 0, heapSize)
      this.swap(arr, 0, --heapSize)
    }
  }
}

```

利用对数器进行验证测试：

```js
const heap = new Heap()

const generateRandomArray = function (maxSize, maxValue) {
  const arr = new Array(Math.floor(Math.random() * (maxSize + 1)))
  for (let i = 0, length = arr.length; i < length; i++) {
    arr[i] =
      Math.floor((maxValue + 1) * Math.random()) -
      Math.floor(maxValue * Math.random())
  }
  return arr
}

// 对数器方法
const main = function (count, size, value) {
  let testTime = count
  let maxSize = size
  let maxValue = value
  let succeed = true
  for (let i = 0; i < testTime; i++) {
    let arr1 = generateRandomArray(maxSize, maxValue)
    let arr2 = JSON.parse(JSON.stringify(arr1)) //拷贝一份
    heap.heapSort(arr1)
    comparator(arr2)
    if (!(JSON.stringify(arr1) === JSON.stringify(arr2))) {
      succeed = false
      break
    }
  }
  console.log(succeed ? '排序正确！！！' : '排序错误!')
}

main(1000, 10, 10)

//结果：排序正确！！！
```

**堆排序的时间复杂度和空间复杂度：**

>- 时间复杂度：O(N*logN)
>- 空间复杂度：O(1)
>- 稳定性：不稳定











